**СОДЕРЖАНИЕ**

[Введение	](#_toc135980221)

[1 Анализ литературных источников и формирование функциональных требований к разрабатываемому программному средство	](#_toc135980222)

[1.1 Анализ существующих аналогов](#_toc135980223)

[1.1.1 Программное средство Structurizer](#_toc135980224)

[1.1.2 Программное средство Edrawmax](#_toc135980225)

[1.1.3 Программное средство Smartdraw](#_toc135980226)

[1.2 Описание средств разработки](#_toc135980227)

[1.2.1 Работа со стеком](#_toc135980228)

[1.2.2 Работа с N-арным деревом](#_toc135980229)

[1.2.3 Работа с файлами	14](#_toc135980230)

[1.3 Спецификация функциональных требований](#_toc135980231)

[2 Проектирование и разработка программного средства](#_toc135980232)

[2.1 Описание алгоритмов решения задачи](#_toc135980233)

[2.2 Структура данных](#_toc135980234)

[2.2.1 Структура типов программы](#_toc135980235)

[2.2.2 Структура данных программы](#_toc135980236)

[2.2.3 Структура данных алгоритма RedefineMainBlock(Self)](#_toc135980237)

[2.2.4 Структура данных алгоритма ChangeGlobalSettings(Self, AOldDefaultAction)](#_toc135980238)

[2.2.5 Структура данных алгоритма TryCutDedicated(Self)](#_toc135980239)

[2.2.6 Структура данных алгоритма TryCopyDedicated(Self)](#_toc135980240)

[2.2.7 Структура данных алгоритма TryDeleteDedicated(Self)](#_toc135980241)

[2.2.8 Структура данных алгоритма TryInsertBufferBlock(Self)](#_toc135980242)

[2.2.9 Структура данных алгоритма TryAddNewStatement (Self, AStatementClass, isAfterDedicated)	](#_toc135980243)

[2.2.10 Структура данных алгоритма TryChangeDedicatedText(Self)](#_toc135980244)

[2.2.11 Структура данных алгоритма TrySortDedicatedCase (Self)](#_toc135980245)

[2.2.12 Структура данных алгоритма ChangeDedicated(Self, AStatement)](#_toc135980246)

[2.2.13 Структура данных алгоритма CreateCarryBlock(Self)](#_toc135980247)

[2.2.14 Структура данных алгоритма MoveCarryBlock(Self, ADeltaX, ADeltaY)](#_toc135980248)

[2.2.15 Структура данных алгоритма DefineHover(Self)](#_toc135980249)

[2.2.16 Структура данных алгоритма TryDrawCarryBlock(Self, AVisibleImageRect)](#_toc135980250)

[2.2.17 Структура данных алгоритма TryTakeAction(Self)](#_toc135980251)

[2.2.18 Структура данных алгоритма DestroyCarryBlock(Self)](#_toc135980252)

[2.2.19 Структура данных алгоритма CreateStatement(AStatementClass, ABaseBlock, Res)](#_toc135980253)

[2.2.20 Структура данных алгоритма TryUndo(Self)](#_toc135980254)

[2.2.21 Структура данных алгоритма TryRedo(Self)](#_toc135980255)

[2.2.22 Структура данных алгоритма TryDrawCarryBlock(Self, AVisibleImageRect)](#_toc135980256)

[2.3 Схемы алгоритмов решения задач по ГОСТ 19.701-90](#_toc135980257)

[2.3.1 Схема алгоритма ChangeGlobalSettings](#_toc135980258)

[2.3.2 Схема алгоритма TryAddNewStatement](#_toc135980259)

[2.3.3 Схема алгоритма ChangeDedicated](#_toc135980260)

[2.3.4 Схема алгоритма TrySortDedicatedCase](#_toc135980261)

[2.3.5 Схема алгоритма MoveCarryBlock](#_toc135980262)

[2.3.6 Схема алгоритма CreateCarryBlock](#_toc135980263)

[2.3.7 Схема алгоритма TryTakeAction](#_toc135980264)

[2.3.8 Схема алгоритма DestroyCarryBlock](#_toc135980265)

[2.3.9 Схема алгоритма CreateStatement](#_toc135980266)

[2.3.10 Схема алгоритма Draw	42](#_toc135980267)

[2.4 Графический интерфейс	44](#_toc135980268)

[2.4.1 Описание графических компонентов формы frmMain](#_toc135980269)

[2.4.2 Описание графических компонентов формы frmGetAction](#_toc135980270)

[2.4.3 Описание графических компонентов формы frmGetCaseConditions](#_toc135980271)

[2.4.4 Описание графических компонентов формы frmGlobalSettings](#_toc135980272)

[2.4.5 Описание графических компонентов формы frmPenSettings](#_toc135980273)

[2.4.6 Описание графических компонентов формы frmHelp](#_toc135980274)

[3 Тестирование и проверка работоспособности программного средства](#_toc135980275)

[3.1 Тестирование основной формы](#_toc135980276)

[3.1.1 Тест 1](#_toc135980277)

[3.1.2 Тест 2](#_toc135980278)

[3.1.3 Тест 3](#_toc135980279)

[3.1.4 Тест 4](#_toc135980280)

[3.1.5 Тест 5](#_toc135980281)

[3.1.6 Тест 6](#_toc135980282)

[3.1.7 Тест 7](#_toc135980283)

[3.1.8 Тест 8](#_toc135980284)

[3.1.9 Тест 9](#_toc135980285)

[3.2 Тестирование формы frmGetAction](#_toc135980286)

[3.2.1 Тест 1	55](#_toc135980287)

[3.2.2 Тест 2	56](#_toc135980288)

[3.3 Тестирование формы frmGetCaseConditions](#_toc135980289)

[3.3.1 Тест 1	56](#_toc135980290)

[3.3.2 Тест 2	57](#_toc135980291)

[3.4 Тестирование формы frmGlobalSettings](#_toc135980292)

[3.4.1 Тест 1](#_toc135980293)

[3.4.2 Тест 2](#_toc135980294)

[3.5 Тестирование формы frmPenSettings](#_toc135980295)

[3.5.1 Тест 1](#_toc135980296)

[3.5.2 Тест 2](#_toc135980297)

[3.6 Тестирование формы frmHelp](#_toc135980298)

[3.6.1 Тест 1](#_toc135980299)

[3.6.2 Тест 2](#_toc135980300)

[4 Руководство по установке](#_toc135980301)

[4.1 Минимальные системные требования](#_toc135980302)

[4.2 Установка](#_toc135980303)

[4.3 Работа с приложением](#_toc135980304)

[Заключение](#_toc135980305)




<a name="_toc135506549"></a> **<a name="_toc135980221"></a>ВВЕДЕНИЕ** 

В настоящее время разработка программного обеспечения является важным аспектом современного мира информационных технологий. Графические редакторы играют ключевую роль в этом процессе, позволяя разработчикам создавать графические модели и схемы, что существенно облегчает процесс разработки. Одним из наиболее распространенных инструментов для создания графических схем является диаграмма Насси-Шнейдермана.

Диаграмма Насси-Шнейдермана является важным инструментом для программистов, поскольку она позволяет легко визуализировать и структурировать алгоритмы и программы. Этот графический подход позволяет разбить большую задачу на более мелкие подзадачи и связать их между собой.

Одним из главных преимуществ диаграмм Насси-Шнейдермана является то, что они делают процесс проектирования программ более наглядным и понятным. Благодаря графическому подходу, программист может быстро оценить сложность алгоритма и определить его эффективность. Кроме того, диаграммы Насси-Шнейдермана помогают быстро выявлять ошибки и улучшать код программы.

Цель данной курсовой работы заключается в разработке графического редактора для создания схем Насси-Шнейдермана с использованием векторной графики. Создание такого редактора может упростить процесс проектирования алгоритмов и облегчить работу программистов. Эта работа также включает исследование процесса разработки программного обеспечения, включая анализ аналогов и выбор наилучших решений в разработке.

В данной работе рассматривается процесс разработки графического интерфейса для программного редактора, который является важным аспектом программного обеспечения. В процессе реализации проекта также решаются задачи создания динамических структур данных, работы с файлами (текстовыми и типизированными), чтения/записи данных из файла, а также разработки пользовательского интерфейса для удобного взаимодействия с программой и повышения ее эффективности.

Таким образом, разработка программного обеспечения является важной сферой в информационных технологиях, и графические редакторы играют ключевую роль в этом процессе. Диаграмма Насси-Шнейдермана, являющаяся важным инструментом для программистов, позволяет легко визуализировать и структурировать алгоритмы и программы. Разработка графического редактора для создания схем Насси-Шнейдермана с использованием векторной графики может упростить процесс проектирования алгоритмов и облегчить работу программистов, что делает данную работу актуальной и востребованной.


1. # <a name="_toc135506550"></a><a name="_toc135980222"></a>**АНАЛИЗ ЛИТЕРАТУРНЫХ ИСТОЧНИКОВ И ФОРМИРОВАНИЕ ФУНКЦИОНАЛЬНЫХ ТРЕБОВАНИЙ К РАЗРАБАТЫВАЕМОМУ ПРОГРАММНОМУ СРЕДСТВО**
   1. ## <a name="_toc135980223"></a>**Анализ существующих аналогов**
      1. ### <a name="_toc132549279"></a><a name="_toc135980224"></a>Программное средство Structurizer
**Structurizer** – это бесплатный графический редактор для создания схем Насси-Шнейдермана. Программа была разработана компанией H.J. Schulz & Co. и предлагает ряд функций, которые делают ее привлекательной для пользователей, занимающихся программированием и проектированием.

Среди основных функций Structurizer можно выделить:

- создание блоков и условных переходов, а также циклов;
- возможность настройки цвета, шрифта и размера элементов диаграммы;
- поддержка импорта и экспорта диаграмм в различных форматах, включая PNG, GIF, JPEG и другие;
- возможность использования дополнительных символов и иконок.

Достоинств Structurizer:

- простота и удобство использования программы;
- бесплатность программы;
- возможность импорта и экспорта диаграмм в различных форматах;
- наличие дополнительных символов и иконок.

Недостатки Structurizer:

- ограниченный функционал, необходимый только для создания схем Насси-Шнейдермана;
- не всегда стабильная работа программы;
- yстаревшее ПО. Structurizer не обновляется уже много лет и не поддерживается разработчиками.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.001.png)

Рисунок 1.1 – Программное средство Structorizer

Structurizer – это простой и удобный инструмент для создания схем Насси-Шнейдермана. Программа имеет достаточно широкий набор функций для решения задач данного типа, и при этом является бесплатной и простой в использовании. Однако, несмотря на эти достоинства, программа иногда может работать нестабильно, что может привести к неудобствам при работе с ней.
1. ### <a name="_toc135980225"></a>Программное средство Edrawmax
**Edrawmax** – это мощный графический редактор, который предоставляет пользователю возможность создавать широкий спектр диаграмм и схем, включая схемы Насси-Шнейдермана. Редактор создан компанией Edrawsoft и имеет ряд функций, которые делают его популярным среди пользователей, занимающихся программированием и проектированием.

Основные функции Edrawmax:

- создание блоков и условных переходов, а также циклов;
- поддержка различных типов соединений и рисунков;
- возможность редактирования цвета, размера, формы и других свойств элементов диаграммы;
- поддержка импорта и экспорта диаграмм в различных форматах, включая PNG, GIF, JPEG, SVG, PDF и другие;
- возможность использования дополнительных символов, шаблонов и шрифтов;
- встроенный набор готовых шаблонов и элементов для быстрого создания диаграмм.

Достоинства EdrawMax:

- мощный и многофункциональный редактор, позволяющий создавать широкий спектр диаграмм;
- большой выбор готовых шаблонов и элементов;
- возможность импорта и экспорта диаграмм в различных форматах;
- наличие дополнительных символов, шаблонов и шрифтов.

К сожалению, Edrawmax не является оптимальным инструментом для построения диаграмм Насси-Шнейдермана. Несмотря на то, что программа имеет некоторые функции, которые могут быть полезны при создании таких диаграмм, у нее есть ряд ограничений и недостатков, которые могут сделать этот процесс менее удобным и эффективным:

- неудобный интерфейс для создания диаграмм Насси-Шнейдермана. Edrawmax не имеет специализированных инструментов для создания диаграмм Насси-Шнейдермана;
- ограниченный функционал для создания диаграмм Насси-Шнейдермана. Edrawmax не имеет специализированных функций для создания диаграмм Насси-Шнейдермана.

Также стоит отметить, что это коммерческое программное обеспечение и для получения полного функционала и доступа к расширенным возможностям, пользователи должны приобрести платную версию программы. 

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.002.png)

Рисунок 1.2 – Программное средство EdrawMax

В целом, хотя Edrawmax предлагает широкий набор инструментов для создания различных типов диаграмм, программа не является оптимальным выбором для создания диаграмм Насси-Шнейдермана.

1. ### <a name="_toc135980226"></a>Программное средство Smartdraw
**Smartdraw** не только представлен в виде десктопного приложения, но и доступен в виде онлайн-версии, что обеспечивает более гибкую работу с программой и возможность доступа к проектам из любой точки с доступом в интернет. Кроме того, онлайн-версия Smartdraw позволяет работать в реальном времени с другими пользователями, обмениваться комментариями и совместно редактировать документы, что делает программу удобной для работы в коллективе.

Среди основных функций SmartDraw можно выделить:

- редактор предоставляет широкий набор инструментов для создания профессиональных диаграмм и схем;
- интеграция с другими приложениями, такими как Microsoft Word, Excel и PowerPoint, а также с Google Workspace, Jira и другими инструментами;
- предоставляет широкий выбор шаблонов для различных типов диаграмм и схем, что упрощает и ускоряет процесс создания;
- предоставляет возможность онлайн-совместной работы, что упрощает совместное использование диаграмм и схем с другими пользователями;
- возможность импорта и экспорта в различных форматах.

Достоинства SmartDraw:

- обширный набор функций, необходимых для создания схем Насси-Шнейдермана;
- возможность настройки цвета, шрифта и размера элементов диаграммы;
- поддержка импорта и экспорта диаграмм в различных форматах;
- легкий интерфейс, понятный даже для новичков;
- возможность использования дополнительных символов и иконок.

Недостатки SmartDraw:

- платное программное обеспечение, необходимо приобретать лицензию для получения доступа к полному функционалу; 
- отсутствие возможности редактирования схем в реальном времени, только локальное сохранение и загрузка диаграмм.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.003.png)

Рисунок 1.3 – Программное средство EdrawMax

Smartdraw – это многофункциональный графический редактор, который может использоваться для создания разнообразных диаграмм и схем, включая схемы Насси-Шнейдермана. Однако, программа не является специализированным инструментом для создания схем Насси-Шнейдермана, поэтому ее функциональность в этой области может быть ограничена.

1. ## <a name="_toc135506554"></a><a name="_toc135980227"></a>**Описание средств разработки**
   1. ### <a name="_toc135980228"></a>Работа со стеком
Стек – это структура данных, которая работает по принципу «последним пришел, первым ушел». В стек можно добавлять элементы только на вершину, а удалять – только верхний элемент. Стек используется в программировании для реализации операции отката, когда нужно отменить последнее действие. Для этого в программе можно использовать стек для хранения истории действий пользователя. Каждое действие представляется как элемент стека, и при нажатии на кнопку «Отменить» из стека извлекается последнее действие и выполняется обратное действие, чтобы отменить его эффект. Таким образом, стек позволяет эффективно реализовывать операцию отмены действий в программе.

В программном средстве для построения схем по методу Насси-Шнейдермана используется стек для поддержки отмены (undo) и повтора (redo) действий пользователя при создании и редактировании схемы. Каждый раз, когда пользователь выполняет какое-либо действие, такое как добавление блока или изменение связей между блоками, состояние схемы сохраняется в стеке. Если пользователь захочет отменить последнее действие, программа извлечет состояние схемы из стека и вернет ее в предыдущее состояние.

Кроме того, стек используется для создания новых условий в блоке case. При создании нового условия в блоке case, программа помещает его в вершину стека. Если пользователь захочет удалить условие, программа просто извлечет его из стека.

Для реализации стека в программе используется список, который позволяет легко добавлять новые элементы и удалять уже существующие.
1. ### <a name="_toc135980229"></a>Работа с N-арным деревом
N-арное дерево – это структура данных, которая представляет собой дерево, в котором каждый узел может иметь несколько дочерних узлов. Каждый узел в n-арном дереве содержит данные и ссылки на его дочерние узлы.

В отличие от двоичных деревьев, где каждый узел имеет не более двух дочерних узлов, в n-арном дереве каждый узел может иметь до n дочерних узлов. N-арное дерево может быть использовано для представления иерархических структур, таких как файловая система или структура сайта.

Каждый узел в n-арном дереве имеет родительский узел, за исключением корневого узла, который не имеет родительского узла. Узлы, у которых нет дочерних узлов, называются листьями.

Одним из преимуществ n-арного дерева является возможность эффективной вставки и удаления узлов в любом месте дерева. Однако, n-арное дерево может иметь более высокую памятьовую стоимость, чем двоичное дерево, так как каждый узел должен хранить ссылки на несколько дочерних узлов.

В программе построения схем Насси-Шнейдермана используется дерево для представления структуры схемы. Каждый узел в дереве представляет блок схемы, такой как условный оператор, цикл или оператор присваивания. Каждый узел также содержит информацию о своих дочерних узлах.

Например, условный оператор может иметь два дочерних узла: один для блока кода, который выполняется, если условие истинно, и другой для блока кода, который выполняется, если условие ложно. Цикл может иметь только один дочерний узел, который представляет тело цикла.

При построении схемы Насси-Шнейдермана программа использует дерево для отображения структуры схемы и для определения последовательности выполнения операторов. Дерево также используется для упрощения построения схемы и валидации ее структуры, что помогает избежать ошибок и упрощает процесс отладки.

Кроме того, в программе также может использоваться дерево для оптимизации процесса построения схемы, так как это позволяет ускорить поиск и доступ к определенным узлам в дереве.

1. ### <a name="_toc135980230"></a>Работа с файлами
Файлы могут быть разделены на две основные категории: логические и физические файлы. Логический файл – это файл, который представляет собой логически связанные данные, имеющие определенную структуру. Он может содержать различные типы данных, такие как текстовые документы, изображения, аудио- и видеофайлы, базы данных и другие. Логический файл определяет формат, структуру и ограничения для данных, которые он содержит. Физический файл, с другой стороны, это непосредственно файл, хранящийся на жестком диске или другом устройстве хранения информации. Физический файл содержит набор битов, которые могут быть интерпретированы как данные, которые он представляет.

Логические и физические файлы тесно связаны друг с другом. Логический файл описывает формат и структуру данных, которые он содержит, а физический файл представляет собой место хранения этих данных на устройстве. Когда данные записываются в логический файл, они сохраняются в соответствующем физическом файле, который затем может быть прочитан для получения этих данных. При чтении данных из логического файла, система оперирует на физическом файле, считывая данные из определенного участка жесткого диска, и затем интерпретирует их в соответствии с форматом логического файла.

Существует три типа файлов: типизированные файлы, текстовые файлы и не типизированные файлы. Типизированные файлы связываются с файловыми переменными, объявленными как «file of <Тип>». Файл считается состоящим из элементов, каждый из которых имеет тип <Тип>. Не типизированные файлы могут быть связаны только с файловыми переменными, которые были объявлены как «file». Файл считается состоящим из элементов, размер которых определяется при открытии файла. Текстовый файл представляет собой последовательность символов, которая может быть разделена на строки. Строки могут быть различной длины (в том числе пустые). В конце каждой строки помещается специальный управляющий символ: возврат каретки (#13 или М международное обозначение CR) и перехода новую строку (#10 или международное обозначение LF). С наличием этого маркера связана логическая функция Eoln (End of line). Эта функция возвращает значение True, если текущая позиция в файле находится в конце строки (т.е. перед символом перехода на новую строку). Текстовые файлы могут быть открыты в одном из двух режимов: для чтения или для записи. Когда файл открывается для чтения, указатель позиции устанавливается на начало файла. Когда файл открывается для записи, содержимое файла удаляется, а указатель позиции устанавливается на начало файла.

Кроме того, текстовые файлы могут быть открыты в режиме добавления, который позволяет добавлять данные в конец файла без удаления его содержимого. Файл, открытый в режиме добавления, всегда открывается для записи, но указатель позиции устанавливается на конец файла.

Важно отметить, что для работы с файлами в программировании нужно уметь открывать и закрывать файлы, читать и записывать данные в файлы, а также обрабатывать ошибки, связанные с файлами, такие как отсутствие файла или ошибка доступа. Также нужно следить за использованием ресурсов компьютера при работе с файлами, чтобы избежать проблем с памятью или производительностью.

Можно сделать вывод о том, что файлы являются важными элементами программирования, которые позволяют хранить и загружать данные в различных форматах. Функции чтения и записи данных в файлы, а также функции управления файлами позволяют программистам создавать приложения, которые сохраняют пользовательские настройки и данные, что делает их более удобными и гибкими в использовании. Типизированные файлы позволяют сохранять данные в определенном формате, что упрощает работу с ними в дальнейшем. Кроме того, использование файлов позволяет пользователям сохранять свою работу и продолжать работать с ней в будущем, что является важным элементом при создании любых приложений.

Пользователи программного средства построения схем Насси-Шнейдермана имеют возможность сохранять свои работы, чтобы впоследствии открыть и продолжить работу с ними. Это позволяет сохранить текущее состояние схемы, включая настройки шрифта, параметры кисти и размещение блоков и операторов. Для этой цели используется специальный формат файла, который обеспечивает структурированное хранение данных схемы. Один из таких форматов – JSON, широко используемый для обмена данными между программами и платформами. JSON позволяет представить данные схемы в виде объектов и массивов, обеспечивая удобство чтения и восстановления информации при открытии сохраненного файла.

Сохранение статистики пользовательской активности также является важной функцией программного средства, позволяющей отслеживать и анализировать взаимодействие пользователей с программой. Это позволяет разработчикам исследовать популярные функции, обнаруживать возможные проблемы или узкие места, а также определять предпочтения пользователей и улучшать функциональность программы на основе этой информации.

В типизированный файл сохраняется статистика пользовательской активности с использованием следующих полей:

- имя пользователя (тип: String): Имя пользователя, который создал или работал с схемой;
- время входа в систему (тип: TDateTime): Дата и время, когда пользователь вошел в программу для работы с схемами;
- время выхода из системы (тип: TDateTime): Дата и время, когда пользователь завершил работу в программе и вышел из нее;
- общее время настройки системы (тип: Integer): Суммарное время, затраченное пользователем на настройку программного средства, включая изменение общих параметров и настройку пользовательского интерфейса;
- время использования справки (тип: Integer): Количество времени, которое пользователь потратил на использование справочной информации в программе;
- время настройки шрифта (тип: Integer): Время, затраченное на выбор и настройку параметров шрифта для текста на схеме;
- время настройки кисти (тип: Integer): Количество времени, затраченное на выбор и настройку параметров кисти, используемой для рисования элементов схемы;
- количество совершенных изменений (тип: Integer): Общее количество изменений, которые пользователь внес в схемы, включая добавление, удаление или изменение блоков и операторов;
- количество удаленных операторов (тип: Integer): Количество операторов, которые были удалены пользователем в процессе работы с схемами;
- количество добавленных операторов (тип: Integer): Количество операторов, которые были добавлены пользователем на схемы в процессе работы.

Кроме того, в программном средстве реализована возможность работы с текстовым файлом, который используется для отображения лицензионного соглашения приложения. Данный файл содержит важную информацию о лицензии, политике конфиденциальности и других документах, которые необходимо ознакомиться пользователю перед началом использования программы.

1. ## <a name="_toc132657043"></a><a name="_toc135980231"></a>**Спецификация функциональных требований**
Программное обеспечение обеспечивает пользователю возможность создавать и редактировать схемы Насси-Шнейдермана.

Функциональные требования – это определенные задачи и функции, которые программа должна выполнять для обеспечения желаемого функционала. Функциональные требования определяются на основе бизнес- и пользовательских требований.

Разрабатываемое программное обеспечение обеспечивает создание приложения, которое позволяет пользователю создавать схемы по методу Насси-Шнейдермана и сохранять их в нужном формате. Бизнес-требования представляют собой общее видение, не включающее детализации поведения системы и технических характеристик.

Также программное также обеспечение должно иметь интуитивно понятный и простой интерфейс, обеспечивающий удобство работы с ним. Это может быть достигнуто с помощью использования понятных иконок и кнопок, простой навигации, интуитивно понятного меню.

Функциональные требования к разрабатываемому ПС приведены в таблице 1.


Таблица 1 – Функциональные требования к программному средству

|Идентификатор|Требование|
| :- | :- |
|ФТ-1|Создание схем по методу Насси-Шнейдермана из каталога блоков|
|ФТ-2|Сохранение истории изменение схемы и отката к предыдущим версиям|
|ФТ-3|Отображение схемы |
|ФТ-4|Создание и загрузка файлов схем|
|ФТ-5|Экспорт в различные форматы|
|ФТ-6|Сохранение и отображение статистики пользователя|
|ФТ-7|Сохранения и загрузки настроек пользовательского интерфейса|
|ФТ-8|Просмотра информации оператора|
|ФТ-9|Редактирование информации оператора|
|ФТ-10|Изменения внешнего вида схемы|

ФТ-1 Создание схем по методу Насси-Шнейдермана из каталога блоков.

Это функциональное требование означает, что пользователь должен иметь возможность создавать схемы по методу Насси-Шнейдермана, используя доступные блоки из каталога. Каталог должен содержать набор стандартных блоков. Пользователь должен иметь возможность выбирать нужные блоки и вставлять их на рабочую область, чтобы создавать схемы.

ФТ-2 Сохранение истории изменение схемы и отката к предыдущим версиям.

Это функциональное требование означает, что пользователь должен иметь возможность сохранять все изменения, внесенные в схему, и возвращаться к предыдущим версиям схемы при необходимости. Это важно, чтобы предотвратить потерю данных и иметь возможность вернуться к предыдущему рабочему состоянию. Для этого можно использовать стек или другие механизмы хранения истории изменений.

ФТ-3 Отображение схемы.

Это функциональное требование означает, что пользователь должен иметь возможность просмотреть созданную им схему. Схема должна быть отображена в удобном для восприятия формате, который позволяет пользователю понимать структуру и последовательность выполнения операций в схеме. Можно использовать графический интерфейс или другой способ отображения схемы.




ФТ-4 Создание и загрузка файлов схем.

Это функциональное требование означает, что пользователь должен иметь возможность сохранять схемы в файлы и загружать их из файлов. Это важно, чтобы пользователь мог сохранить свою работу и поделиться ею с другими пользователями. 

ФТ-5 Экспорт в различные форматы.

Это функциональное требование позволяет пользователю экспортировать созданную схему в различные форматы, такие как PNG, JPEG, PDF и другие. Экспортирование схемы в различные форматы позволяет пользователю сохранить ее в удобном для просмотра формате и поделиться с другими людьми.

ФТ-6 Сохранение и отображение статистики пользователя.

Это функциональное требование позволяет сохранять информацию о действиях и активности пользователя для последующего отображения. Статистика включает такие данные как имя пользователя, время входа и выхода из системы, время настройки системы, использование справки, настройку шрифта и кисти, количество совершенных изменений, удаленных и добавленных операторов. Это позволяет пользователям отслеживать свою активность и проделанную работу.

ФТ-7 Сохранения и загрузки настроек пользовательского интерфейса.

Это функциональное требование позволяет пользователю сохранять свои настройки пользовательского интерфейса, такие как цвет заднего фона, настройки кисти и другие. После сохранения пользователь может загрузить эти настройки и сразу начать работу со схемой в своей привычной среде.

ФТ-8 Просмотр информации о блоке.

Это функциональное требование позволяет пользователю просматривать информацию о выбранном блоке. Такую как наименование действия и условия, если имеются. 

ФТ-9 Редактирование информации о блоке.

Это функциональное требование позволяет пользователю редактировать информацию о выбранном блоке. Такую как наименование действия и условия, если имеются.

ФТ-10 Изменения внешнего вида блоков.

Это функциональное требование позволяет пользователю изменять внешний вид блоков, такой как цвет, шрифт, размер и т.д. Это может быть полезно, если пользователю нужно выделить определенные блоки на схеме или изменить их внешний вид для удобства восприятия.
1. # <a name="_toc132549287"></a><a name="_toc135980232"></a>**ПРОЕКТИРОВАНИЕ И РАЗРАБОТКА ПРОГРАММНОГО СРЕДСТВА**
   1. ## <a name="_toc132549288"></a><a name="_toc135980233"></a>**Описание алгоритмов решения задачи**
Таблица 2 – Описание алгоритмов решения задачи

|<p>№</p><p>п.п. </p>|Наименование алгоритма|Название алгоритма|<p>Формальные </p><p>параметры</p>|Предпола-гаемый тип реализации|
| :- | :- | :- | :- | :- |
|1 |Основной алгоритм|<p>Вызывает следующие подпрограммы:</p><p>RedefineMainBlock, ChangeGlobalSettings, TryCut-</p><p>Dedicated, TryCopyDedicated,TryDeleteDedicated, TryInsertBuerBlock, TryMoveDedicated, TryChangeDedicatedText, TryAdd-</p><p>NewStatement, TrySortDedicatedCase, CreateCarryBlock, MoveCarryBlock, DefineHover, TryDrawCarryBlock, TryTakeAction, DestroyCarryBlock, CreateStatement, TryUndo, TryRedo, Draw.</p>|||
|2|<p>RedefineMainBlock </p><p>(</p><p>Self</p><p>)</p>|Производит переопределение размера схемы для Self|Self – получает от фактического параметра адрес с защитой|Процедура|

Продолжение таблицы 2

|3|<p>ChangeGlobalSettings</p><p>` `(</p><p>Self, </p><p>AOldDefaultAction</p><p>)</p>|Изменяет глобальные настройки для объекта Self. В случае, если новое действие по умолчанию не равно значению параметра AOldDefaultAction, происходит вызов подпрограммы RedefineMainBlock с передачей объекта Self в качестве параметра|<p>Self – получает от фактического параметра адрес с защитой.</p><p>AOldDefaultAction – получает от фактического параметра адрес с защитой </p>|Процедура|
| :- | :- | :- | :- | :- |
|4|<p>TryCutDedicated</p><p>(</p><p>Self</p><p>)</p>|<p>Вызывает подпрограммы TryCopy- Dedicated и TryDelete-</p><p>Dedicated, передавая Self в качестве параметра.</p>|Self – получает от фактического параметра адрес с защитой|Процедура|
|5|<p>TryDeleteDedicated </p><p>(</p><p>Self</p><p>)</p>|Производит удаление выделенного оператора у объекта Self, если такой оператор существует.|Self – получает от фактического параметра адрес с защитой|Процедура|
|6|<p>TryCopyDedicated</p><p>(</p><p>Self</p><p>)</p>|Копирует выделенный оператор, находящийся в объекте Self, если такой оператор существует.|Self – получает от фактического параметра адрес с защитой|Процедура|
|7|<p>TryInsertBufferBlock</p><p>(</p><p>Self</p><p>)</p>|Добавляет в переменную Self новый буферный оператор после выделенного оператора, если таковой имеется.|Self – получает от фактического параметра адрес с защитой|Процедура|

Продолжение таблицы 2

|8|<p>TryMoveDedicated</p><p>(</p><p>Self, </p><p>ASetScrollPosProc,</p><p>AKey</p><p>)</p>|Перемещает выделенный оператор в переменной Self в соответствии со значением переменной AKey. Если перемещение выполнено успешно, то вызывает подпрограмму ASetScrollPosProc.|<p>Self – получает от фактического параметра адрес с защитой.</p><p>ASetScrollPosProc – получает от фактического </p><p>параметра адрес с защитой.</p><p>AKey – получает от фактического параметра адрес с защитой</p>|Процедура|
| :- | :- | :- | :- | :- |
|9|<p>TryAddNewStatement </p><p>(</p><p>Self,</p><p>AStatementClass,</p><p>isAfterDedicated</p><p>)</p>|Вызывает подпрограмму CreateStatement с параметрами AStatementClass и базовым блоком выделенного оператора переменной Self для создания нового оператора. Он добавляется после или до выделенного оператора в зависимости от значения переменной isAfterDedicated|<p>Self – получает от фактического параметра адрес с защитой.</p><p>AStatementClass – получает от фактического параметра адрес с защитой.</p><p>isAfterDedicated</p><p>– получает от фактического параметра адрес с защитой</p>|Процедура|
|10|<p>TryChangeDedicatedText</p><p>(</p><p>Self</p><p>)</p>|Обновляет действие у выделенного оператора переменной Self, если он существует|Self – получает от фактического параметра адрес с защитой|Процедура|
|11|<p>TrySortDedicatedCase</p><p>(</p><p>Self</p><p>)</p>|Если выделенный оператор переменной Self является оператором множественного выбора, то сортирует его условия|Self – получает от фактического параметра адрес с защитой|Процедура|

Продолжение таблицы 2

|12|<p>ChangeDedicated</p><p>(</p><p>Self,</p><p>AStatement</p><p>)</p>|Меняет значение переменной Self на AStatement для выделенного оператора |Self – получает от фактического параметра адрес с защитой|Процедура|
| :- | :- | :- | :- | :- |
|13|<p>CreateCarryBlock</p><p>(<br>Self<br>)</p>|Создает у переменной Self переносимый блок.|Self – получает от фактического параметра адрес с защитой|Процедура|
|14|<p>MoveCarryBlock</p><p>(</p><p>Self,</p><p>ADeltaX,</p><p>ADeltaY</p><p>)</p>|Смещает переносимый блок переменной Self на ADeltaX по оси X и на ADeltaY по оси Y|<p>Self – получает от фактического параметра адрес с защитой.</p><p>ADeltaX – получает от фактического параметра адрес с защитой.</p><p>ADeltaY– получает от фактического параметра адрес с защитой</p>|Процедура|
|15|<p>DefineHover</p><p>(</p><p>Self,</p><p>AX,</p><p>AY</p><p>)</p>|Поиск оператора, содержащего координаты (AX, AY) и, если оператор найден, присваивает его в наведенный оператор переменной Self и определяет для него действие|<p>Self – получает от фактического параметра адрес с защитой.</p><p>AX – получает от фактического параметра адрес с защитой.</p><p>AY – получает от фактического параметра адрес с защитой</p>|Процедура|
|16|<p>TryDrawCarryBlock</p><p>(</p><p>Self,</p><p>AVisibleImageRect</p><p>)</p>|<p>Отрисовывает все операторы переносимого блока у переменной Self, которые входят в границы AVisibleImageRect</p><p></p>|<p>Self – получает от фактического параметра адрес с защитой.</p><p>AVisibleImageRect – получает от фактического параметра адрес с защитой</p>|Процедура|

Продолжение таблицы 2

|17|<p>TryTakeAction</p><p>(</p><p>Self</p><p>)</p>|Выполняет действие с выделенным блоком переменной Self в зависимости от действия наведенного оператора переменной Self.|<p>Self – получает от фактического параметра адрес с защитой</p><p></p>|Процедура|
| :- | :- | :- | :- | :- |
|18|<p>DestroyCarryBlock</p><p>(</p><p>Self</p><p>)</p>|Удаляет переносимый блок переменной Self|<p>Self – получает от фактического параметра адрес с защитой</p><p></p>|Процедура|
|19|<p>CreateStatement</p><p>(</p><p>AStatementClass,</p><p>ABaseBlock, </p><p>Res</p><p>)</p>|Создает оператор типа AStatementClass с базовым блоком ABaseBlock и записывает его в переменную Res|<p>AStatementClass – получает от фактического параметра адрес с защитой.</p><p>ABaseBlock – получает от фактического параметра адрес с защитой.</p><p>Res – получает от фактического параметра адрес, возвращаемый параметр</p>|Функций. Res – возвращаемый функцией параметр|
|20|<p>TryUndo</p><p>(</p><p>Self</p><p>)</p>|Отменяет последнее действие, выполненное над переменной Self|<p>Self – получает от фактического параметра адрес с защитой</p><p></p>|Процедура|
|21|<p>TryRedo</p><p>(</p><p>Self</p><p>)</p>|Выполняет отмену последнего ранее отмененного действия, связанного с переменной Self.|<p>Self – получает от фактического параметра адрес с защитой</p><p></p>|Процедура|




Продолжение таблицы 2

|22|<p>InitializeBlocks (</p><p>Self,</p><p>AIndex</p><p>)</p>|Выполняет инициализацию блоков внутри оператора Self. Она устанавливает начальные позиции блоков и производит их выравнивание, начиная с индекса AIndex|<p>Self – получает от фактического параметра адрес с защитой.</p><p>AIndex</p><p>– получает от фактического параметра значение</p><p></p>|Процедура|
| :- | :- | :- | :- | :- |

1. ## <a name="_toc135980234"></a>**Структура данных** 
   1. ### <a name="_toc135980235"></a>Структура типов программы
Таблица 3 – Структура типов программы

|Элементы данных |Рекомендуемый тип|Назначение |
| :- | :- | :- |
|TBlock|<p>Record</p><p>`    `FXStart, FXLast: </p><p>`                     `Integer;</p><p>`    `FCanvas: TCanvas;</p><p>`    `FStatements: array of            </p><p>`                     `^Statement</p><p>`    `FBaseOperator: </p><p>`                     `^TOperator</p><p>End;</p>|Блок, в котором содержатся операторы, хранит адрес на базовый оператор. Задает ограничение для вложенный операторов по Х|
|PBlock|^TBlock|Тип, предназначенный для обозначения указателя на блок|
|TStatement|<p>Record</p><p>`    `FYStart, FYLast: Integer;</p><p>`    `FAction: String;</p><p>`    `BaseBlock: ^TBlock           End;</p>|Оператор, который хранит действие и задает коодинаты по Y. Хранит адрес на базовый блок|
|PStatement|^TStatement|Предназначен для обозначения указателя на блок|
|TOperator|<p>Record(PStatement)</p><p>`    `FBlocks: array of </p><p>`                   `^TBlock   </p><p>End</p>|Оператор, который содержит в себе блоки|

<a name="_toc132549298"></a>Продолжение таблицы 3

|POperator|^TOperator|Предназначен для обозначения указателя на блок|
| :- | :- | :- |
|<p>THovered-</p><p>Statement</p>|<p>Record</p><p>`   `Statement: TStatement;</p><p>`   `Rect: TRect;</p><p>`   `State: TState;</p><p>End;</p>|Определяет наведенный оператор и его состояние|
|TSetScrollPosProc|Procedure(const AStatement: TStatement) of object|Процедурный тип, который управляет положением скролла в заданной позиции|
|PItem|^TItem|Указатель на элемент|
|Item |<p>Record</p><p>`     `FData: T;</p><p>`     `FNext: PItem;</p><p>End;</p>|Элемент, содержащий данные и указатель на следующий элемент|
|TStack|<p>Record</p><p>`    `FTop: PItem;</p><p>`    `FCount: Integer;</p><p>End</p>|Представляет стек, хранящий указатель на первый элемент и количество элементов в стеке|
|TBlockManager|<p>Record</p><p>`    `FBufferBlock: TBlock;</p><p>`    `FCarryBlock: TBlock;</p><p>`    `FHoveredStatement:    </p><p>`          `THoveredStatement;</p><p>`    `FMainBlock : TBlock;</p><p>`    `FDedicatedStatement: </p><p>`                `TStatement;</p><p>`    `FPaintBox: TPaintBox;</p><p>`    `FPen: TPen;</p><p>`    `FFont: TFont;</p><p>End;</p>|Этот объект предназначен для работы с операторами и блоками внутри схемы|
1. ### <a name="_toc135980236"></a>Структура данных программы
Таблица 4 – Структура данных программы

|Элементы данных |Рекомендуемый тип|Назначение |
| :- | :- | :- |
|FBlockManager|TBlockManager|Работа с операторами и блоками внутри схемы|
|`    `FUndoStack|TStack|Стек для отмены действий|
|`    `FRedoStac|TStack|Стек для отмен последних отмененных действий|
1. ### <a name="_toc135980237"></a>Структура данных алгоритма RedefineMainBlock(Self)
Таблица 5 – Структура данных RedefineMainBlock(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
1. ### <a name="_toc135980238"></a>Структура данных алгоритма ChangeGlobalSettings(Self, AOldDefaultAction)
Таблица 6 – Структура данных ChangeGlobalSettings(Self, AOldDefaultAction)


|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|AOldDefaultAction|String|Предыдущее значение действия по умолчанию|Формальный|

1. ### <a name="_toc135980239"></a>Структура данных алгоритма TryCutDedicated(Self)
Таблица 7 – Структура данных TryCutDedicated(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|



1. ### <a name="_toc135980240"></a>Структура данных алгоритма TryCopyDedicated(Self)
Таблица 8 – Структура данных TryCopyDedicated(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
1. ### <a name="_toc135980241"></a>Структура данных алгоритма TryDeleteDedicated(Self)
Таблица 9 – Структура данных TryDeleteDedicated(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
1. ### <a name="_toc135980242"></a>Структура данных алгоритма TryInsertBufferBlock(Self)
Таблица 10 – Структура данных TryInsertBufferBlock(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|BaseBlock|TBlock|Получение базового блока выделенного оператора|Локальный|
|I|Integer|Счетчик цикла|Локальный|
|<p></p><p></p>||||
1. ### <a name="_toc135980243"></a>Структура данных алгоритма TryAddNewStatement (Self, AStatementClass, isAfterDedicated)
Таблица 11 – Структура данных TryAddNewStatement (Self, AStatementClass, isAfterDedicated)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|AStatementClass|Integer|Переменная указывает тип оператора, который будет создан|Формальный|
|isAfterDedicated|Boolean|Флаг, указывающий, добавлять ли новый оператор|Формальный|
|NewStatement|TStatement|Хранит созданный оператор|Локальный|
|Block|TBlock|Хранит базовый блок созданного оператора|Локальный|
1. ### <a name="_toc135980244"></a>Структура данных алгоритма TryChangeDedicatedText(Self)
Таблица 12 – Структура данных TryChangeDedicatedText(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|Action|String|Хранит новое действие для выделенного оператора|Локальный|
|||||
1. ### <a name="_toc135980245"></a>Структура данных алгоритма TrySortDedicatedCase (Self)
Таблица 13 – Структура данных TrySortDedicatedCase (Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
1. ### <a name="_toc135980246"></a>Структура данных алгоритма ChangeDedicated(Self, AStatement)
Таблица 14 – Структура данных ChangeDedicated(Self, AStatement)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|AStatement|TStatement|Хранит новый выделенный блок|Формальный|
1. ### <a name="_toc135980247"></a>Структура данных алгоритма CreateCarryBlock(Self)
Таблица 15 – Структура данных CreateCarryBlock(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|<p></p><p></p><p></p><p></p><p></p><p></p>||||
1. ### <a name="_toc135980248"></a>Структура данных алгоритма MoveCarryBlock(Self, ADeltaX, ADeltaY)
Таблица 16 – Структура данных MoveCarryBlock(Self, ADeltaX, ADeltaY)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|ADeltaX|Integer|Смещение по координате X|Формальный|
|ADeltaY|Integer|Смещение по координате Y|Формальный|
1. ### <a name="_toc135980249"></a>Структура данных алгоритма DefineHover(Self)
Таблица 17 – Структура данных DefineHover(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|Indent|Integer|Отступ от начала оператора|Локальный|
1. ### <a name="_toc135980250"></a>Структура данных алгоритма TryDrawCarryBlock(Self, AVisibleImageRect)
Таблица 18 – Структура данных TryDrawCarryBlock(Self, AVisibleImageRect)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
|AVisibleImageRect|TVisibleImageRect|Информация о видимой границе|Формальный|
1. ### <a name="_toc135980251"></a>Структура данных алгоритма TryTakeAction(Self)
Таблица 19 – Структура данных TryTakeAction(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|


1. ### <a name="_toc135980252"></a>Структура данных алгоритма DestroyCarryBlock(Self)
Таблица 20 – Структура данных DestroyCarryBlock(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
1. ### <a name="_toc135980253"></a>Структура данных алгоритма CreateStatement(AStatementClass, ABaseBlock, Res)
Таблица 21 – Структура данных CreateStatement(AStatementClass, ABaseBlock, Res)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|AStatementClass|Integer|Переменная указывает тип оператора, который будет создан|Формальный|
|ABaseBlock|TBlock|Базовый блок, в котором будет создан оператор|Формальный|
|Res|TStatement|Созданный оператор|Формальный|
|Action|String|Хранит новое действие для нового оператора|Локальный|
1. ### <a name="_toc135980254"></a>Структура данных алгоритма TryUndo(Self)
Таблица 22 – Структура данных TryUndo(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|

1. ### <a name="_toc135980255"></a>Структура данных алгоритма TryRedo(Self)
Таблица 23 – Структура данных TryRedo(Self)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TBlockManager|Обеспечивает доступ к информации о блоках и операторах|Формальный|
1. ### <a name="_toc135980256"></a>Структура данных алгоритма TryDrawCarryBlock(Self, AVisibleImageRect)
Таблица 24 – Структура данных InitializeBlocks(Self, AIndex)

|Элементы данных |Рекомендуемый тип|Назначение |Тип параметра|
| :- | :- | :- | :- |
|Self|TOperator|Оператор, требующий инициализации|Формальный|
|AIndex|Integer|Индекс, с которого начинается инициализация и выравнивание блоков внутри оператора Self|Формальный|
|I|Integer|Счетчик цикла|Локальный|
|BlockYStart|Integer|Вертикальная позиция, с которой начинается текущий блок|Локальный|
1. ## <a name="_toc134925247"></a><a name="_toc135980257"></a>**Схемы алгоритмов решения задач по ГОСТ 19.701-90**
   1. ### <a name="_toc134925248"></a><a name="_toc135980258"></a>Схема алгоритма ChangeGlobalSettings
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.004.png)

Рисунок 2.1 – Схема алгоритма ChangeGlobalSettings







1. ### <a name="_toc135980259"></a>Схема алгоритма TryAddNewStatement
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.005.png)

Рисунок 2.2 – Схема алгоритма TryAddNewStatement

1. ### <a name="_toc135980260"></a>Схема алгоритма ChangeDedicated
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.006.png)

Рисунок 2.3 – Схема алгоритма ChangeDedicated


















1. ### <a name="_toc135980261"></a>Схема алгоритма TrySortDedicatedCase
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.007.png)

Рисунок 2.4 – Схема алгоритма TrySortDedicatedCase













1. ### <a name="_toc135980262"></a>Схема алгоритма MoveCarryBlock
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.008.png)

Рисунок 2.5 – Схема алгоритма MoveCarryBlock


















1. ### <a name="_toc135980263"></a>Схема алгоритма CreateCarryBlock
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.009.png)

Рисунок 2.6 – Схема алгоритма CreateCarryBlock


















1. ### <a name="_toc135980264"></a>Схема алгоритма TryTakeAction

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.010.png)

Рисунок 2.7 – Схема алгоритма TryTakeAction









1. ### <a name="_toc135980265"></a>Схема алгоритма DestroyCarryBlock
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.011.png)

Рисунок 2.8 – Схема алгоритма DestroyCarryBlock








1. ### <a name="_toc135980266"></a>Схема алгоритма CreateStatement
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.012.png)

Рисунок 2.9 – Схема алгоритма CreateStatement






1. ### <a name="_toc135980267"></a>Схема алгоритма Draw
![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.013.png)

Рисунок 2.10 – Схема алгоритма Draw (часть 1)

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.014.png)

Рисунок 2.11 – Схема алгоритма Draw (часть 2)
















1. ## <a name="_toc134925258"></a><a name="_toc135980268"></a>**Графический интерфейс**
Для организации графического интерфейса программного средства было использовано 6 форм: frmMain, frmGetAction, frmGetCaseConditions, frmGlobalSettings, frmPenSettings, frmHelp.
1. ### <a name="_toc134925259"></a><a name="_toc135042044"></a><a name="_toc135980269"></a>Описание графических компонентов формы frmMain
Форма Main является основной формой программного средства Насси-Шнейдермана, предоставляющей пользователю доступ к основным функциям программы. Эта форма позволяет пользователю вводить значения, отображать дерево, настраивать его параметры, а также вызывать другие формы и выполнять другие действия. Она обладает соответствующим интерфейсом, представленным на рисунке. Форма Main является ключевым элементом пользовательского опыта в программном средстве Насси-Шнейдермана и обеспечивает удобное и эффективное взаимодействие с функциональностью программы.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.015.png)

Рисунок 2.12 – Основное окно программы

Составляющие формы Main:

1. Панель «tbMain», на которой расположены следующие компоненты:
- кнопка «tbNew» очищает схему программного средства до начального состояния;
- кнопка «tbOpen» выполняет открытие файла из указанной директории;
- кнопка «tbSave» выполняет перезапись последнего файла либо вызывает «SaveAs»;
- кнопка «tbUndo» отменяет последнее действие;
- кнопка «tbRedo» возвращает отмененное действие;
- кнопка «tbCut» вырезает выделенный блок;
- кнопка «tbCopy» копирует выделенный блок;
- кнопка «tbInsert» вставляет копию после выделенного блока;
- кнопка «tbAction» изменяет действие у выделенного блока;
- кнопка «tbDelete» удаляет выделенный блок;
- кнопка «tbProcess» добавляет блок процесса после выделенного блока;
- кнопка «tbIfBranch» добавляет условный блок после выделенного блока;
- кнопка «tbMultBranch» добавляет блок множественного выбора после выделенного блока;
- кнопка «tbLoop» добавляет цикл с предусловием после выделенного блока;
- кнопка «tbRevLoop» добавляет цикл с постусловием после выделенного блока;
- кнопка «tbSortAsc» сортирует условия блока множественного выбора по возрастанию;
- кнопка «tbSortDecs» сортирует условия блока множественного выбора по убыванию;
- кнопка «tbFont» выполняет изменение шрифта;
- кнопка «tbPen» выполняет изменение кисти;
- кнопка «tbGlSettings» выполняет изменение глобальных настроек;
- кнопка «tbUserGuide» отображает информацию об приложении;
- кнопка «tbAbout» отображает информацию об авторею.
1. Компонент «ScrollBox» содержит в себе компонент «PaintBox», на котором отображается схема.
1. Компонент «MainMenu», содержащий следующие поля:
- поле «mnNew» очищает схему программного средства до начального состояния;
- поле «mnOpen» выполняет открытие файла из указанной директории;
- поле «mnSave» выполняет перезапись последнего файла либо вызывает «SaveAs»;
- поле «mnExpSVG» выполняет сохранение файла в формате SVG указанную директорию;
- поле «mnExpBMP» выполняет сохранение файла в формате BMP указанную директорию;
- поле «mnExpPNG» выполняет сохранение файла в формате PNG указанную директорию;
- поле «mnExit» выполняет закрытие приложения;
- поле «mnUndo» отменяет последнее действие;
- поле «mnRedo» возвращает отмененное действие;
- поле «mnCut» вырезает выделенный блок;
- поле «mnCopy» копирует выделенный блок;
- поле «mnInsert» вставляет копию после выделенного блока;
- поле «mnAction» изменяет действие у выделенного блока;
- поле «mnDelete» удаляет выделенный блок;
- поле «mnAction» изменяет действие у выделенного блока;
- поле «mnDelete» удаляет выделенный блок;
- поле «mnAftProcess» добавляет блок процесса после выделенного блока;
- поле «mnAftIfBranch» добавляет условный блок после выделенного блока;
- поле «mnAftMultBranch» добавляет блок множественного выбора после выделенного блока;
- поле «mnAftLoop» добавляет цикл с предусловием после выделенного блока;
- поле «mnAftRevLoop» добавляет цикл с постусловием после выделенного блока;
- поле «mnBefProcess» добавляет блок процесса перед выделенным блоком;
- поле «mnBefIfBranch» добавляет условный блок перед выделенным блоком;
- поле «mnBefMultBranch» добавляет блок множественного выбора перед выделенным блоком;
- поле «mnBefLoop» добавляет цикл с предусловием перед выделенным блоком;
- поле «mnBefRevLoop» добавляет цикл с постусловием перед выделенным блоком;
- поле «mnSortAsc» сортирует условия блока множественного выбора по возрастанию;
- поле «mnSortDecs» сортирует условия блока множественного выбора по поле;
- поле «mnFont» выполняет изменение шрифта;
- поле «mnPen» выполняет изменение кисти;
- поле «mnGlSettings» выполняет изменение глобальных настроек;
- поле «mnUserGuide» отображает информацию об приложении;
- поле «mnAbout» отображает информацию об авторе;
- поле «mnCurrentStat» отображает текущую статистику пользователя;
- поле «mnOtherStat» выполняет открытие файла статистика из указанной директории и отображает ее.




1. ### <a name="_toc135980270"></a>Описание графических компонентов формы frmGetAction
Форма frmGetAction предоставляет пользователю возможность ввода действий для блока, позволяя определить необходимые операции или инструкции.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.016.png)

Рисунок 2.13 – Окно ввода действия

Составляющие формы frmGetAction:

- кнопка «btnCancel» отменяет ввод действия;
- кнопка «btnOk» сохраняет ввод действия;
- компонент «MemoAction» осуществляет ввод действия.
  1. ### <a name="_toc135980271"></a>Описание графических компонентов формы frmGetCaseConditions
Форма frmGetCaseConditions предоставляет пользователю возможность ввода условий, позволяя определить различные сценарии или варианты выполнения в зависимости от заданных условий.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.017.png)

Рисунок 2.14 – Окно ввода условий

Составляющие формы frmGetCaseConditions:

- кнопка «btnCancel» отменяет ввод действия;
- кнопка «btnOk» сохраняет ввод действия;
- кнопка «btnAdd» добавляет условие;
- кнопка «btnDelete» удаляет условие;
- компоненты «mmFirst, mmSecond, mmThird, mmFourth» осуществляет ввод условий.
  1. ### <a name="_toc135980272"></a>Описание графических компонентов формы frmGlobalSettings
Форма "frmGlobalSettings" предоставляет пользователю возможность изменения глобальных настроек схемы, позволяя настраивать параметры и свойства, которые применяются ко всем блокам и элементам схемы. Это позволяет пользователю осуществлять широкий контроль над общими характеристиками схемы и адаптировать их под свои потребности и предпочтения.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.018.png)

Рисунок 2.15 – Окно глобальных настроек

Составляющие формы frmGlobalSettings:

- кнопка «btnCancel» отменяет ввод действия;
- кнопка «btnOk» сохраняет ввод действия;
- кнопка «btnRestore» восстанавливает изначальные настройки программы;
- компонент «shpHighlight» устанавливает цвет для выделенного блока;
- компонент «shpOK» устанавливает цвет для отображения допустимо-сти операции;
- компонент «shpCancel» устанавливает цвет для отображения недопустимо-сти операции;
- компонент «shpArrow» устанавливает цвет для отображения стрелок;
- компонент «mmTrue» осуществляет ввод для истинного условия;
- компонент «mmFalse» осуществляет ввод для ложного условия;
- компонент «mmDefault» осуществляет ввод ввод для действия блока по умолчанию.
  1. ### <a name="_toc135980273"></a>Описание графических компонентов формы frmPenSettings
Форма frmPenSettings предоставляет пользователю возможность изменять настройки кисти, позволяя настраивать параметры и характеристики, связанные с рисованием и отображением элементов на схеме. Здесь пользователь может настраивать толщину кисти, тип линий и выбирать цвет, определяющий внешний вид рисуемых элементов. Это позволяет пользователю индивидуализировать стиль и эстетические аспекты схемы в соответствии с его предпочтениями и требованиями.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.019.png)

Рисунок 2.16 – Окно настройки кисти

Составляющие формы frmPenSettings:

- кнопка «btnCancel» отменяет ввод действия;
- кнопка «btnOk» сохраняет ввод действия;
- компонент «cbLineType» устанавливает тип линий кисти;
- компонент «cbThickness» устанавливает толщину кисти;
- компонент «CurrColor» устанавливает цвет кисти.
  1. ### <a name="_toc135980274"></a>Описание графических компонентов формы frmHelp
Форма frmHelp предоставляет пользователю возможность получить информацию о программе или авторе. Здесь пользователь может ознакомиться с справочными материалами, руководством пользователя или другой полезной информацией, которая поможет ему более полно использовать программное средство. Также форма может содержать информацию об авторе, его контактных данных или другие сведения, которые могут быть интересными для пользователей программы.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.020.png)

Рисунок 2.17 – Окно информации

Форма содержит компонент «WebBrowser» для отображения HTML документа.
1. # <a name="_toc135506591"></a><a name="_toc135980275"></a>**ТЕСТИРОВАНИЕ И ПРОВЕРКА РАБОТОСПОСОБНОСТИ ПРОГРАММНОГО СРЕДСТВА**
   1. ## <a name="_toc135042048"></a><a name="_toc135980276"></a><a name="_toc134709870"></a><a name="_toc134912901"></a><a name="_toc135506593"></a>**Тестирование основной формы**
      1. ### <a name="_toc135980277"></a>Тест 1
Таблица 25 – Тест 1

|Тестовая ситуация:|Проверка корректности поведения программы при запуске|
| :- | :- |
|Исходный набор данных:|Запуск программы|
|Ожидаемый результат:|Открытие формы Main, отображение схемы|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.021.png)|
1. ### <a name="_toc135980278"></a>Тест 2
Таблица 26 – Тест 2

|Тестовая ситуация:|Проверка корректности поведения программы при добавлении блока процесса|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbProcess, ввод действия|
|Ожидаемый результат:|Добавление блока процесса|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.022.png)|
1. ### <a name="_toc135980279"></a>Тест 3
Таблица 27 – Тест 3

|Тестовая ситуация:|Проверка корректности поведения программы при добавлении условного блока|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbIfBranch, ввод действия|
|Ожидаемый результат:|Добавление условного блока|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.023.png)|
1. ### <a name="_toc135980280"></a>Тест 4
Таблица 28 – Тест 4

|Тестовая ситуация:|Проверка корректности поведения программы при добавлении блока множественного выбора|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbIfMultBranch, ввод действия и условий|
|Ожидаемый результат:|Добавление блока множественного выбора|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.024.png)|
|||
1. ### <a name="_toc135980281"></a>Тест 5
Таблица 29 – Тест 5

|Тестовая ситуация:|Проверка корректности поведения программы при сортировке условий блока множественного выбора|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbSortAsc|
|Ожидаемый результат:|Отсортированные условия по возрастанию|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.025.png)|
1. ### <a name="_toc135980282"></a>Тест 6
Таблица 30 – Тест 6

|Тестовая ситуация:|Проверка корректности поведения программы при сортировке условий блока множественного выбора|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbSortDesc|
|Ожидаемый результат:|Отсортированные условия по убыванию|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.026.png)|



1. ### <a name="_toc135980283"></a>Тест 7
Таблица 31 – Тест 7

|Тестовая ситуация:|Проверка корректности поведения программы при добавлении цикла с предусловием|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbLoop, ввод действия|
|Ожидаемый результат:|Добавление цикла с предусловием|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.027.png)|
1. ### <a name="_toc135980284"></a>Тест 8
Таблица 32 – Тест 8

|Тестовая ситуация:|Проверка корректности поведения программы при добавлении цикла с постусловием|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbRevLoop, ввод действия|
|Ожидаемый результат:|Добавление цикла с постусловием|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.028.png)|


1. ### <a name="_toc135980285"></a>Тест 9
Таблица 33 – Тест 9

|Тестовая ситуация:|Проверка корректности поведения программы при удалении блока|
| :- | :- |
|Исходный набор данных:|Нажатие на компонент PaintBox в области, где расположен условный блок. Затем нажатие на кнопку tbDelete|
|Ожидаемый результат:|Удаление условного блока|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.029.png)|

1. ## <a name="_toc135042057"></a><a name="_toc135980286"></a>**Тестирование формы frmGetAction**
   1. ### <a name="_toc135980287"></a>Тест 1
Таблица 34 – Тест 1

|Тестовая ситуация:|Проверка корректности поведения программы при изменении действия на однострочный текст у блока|
| :- | :- |
|Исходный набор данных:|Ввод однострочного текста|
|Ожидаемый результат:|Изменение действия у блока|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.030.png)|





1. ### <a name="_toc135980288"></a>Тест 2
Таблица 35 – Тест 2

|Тестовая ситуация:|Проверка корректности поведения программы при изменении действия на многострочный текст у блока|
| :- | :- |
|Исходный набор данных:|Ввод многострочного текста|
|Ожидаемый результат:|Изменение действия у блока|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.031.png)|

1. ## <a name="_toc135980289"></a>**Тестирование формы frmGetCaseConditions**
   1. ### <a name="_toc135980290"></a>Тест 1
Таблица 36 – Тест 1

|Тестовая ситуация:|Проверка корректности поведения программы при изменении условий на однострочный текст у блока множественного выбора|
| :- | :- |
|Исходный набор данных:|Ввод однострочного текста|
|Ожидаемый результат:|Изменение условий у блока множественного выбора|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.032.png)|



1. ### <a name="_toc135980291"></a>Тест 2
Таблица 37 – Тест 2

|Тестовая ситуация:|Проверка корректности поведения программы при изменении условий на многострочный текст у блока множественного выбора|
| :- | :- |
|Исходный набор данных:|Ввод многострочного текста|
|Ожидаемый результат:|Изменение условий у блока множественного выбора|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.033.png)|

1. ## <a name="_toc135980292"></a>**Тестирование формы frmGlobalSettings**
   1. ### <a name="_toc135980293"></a>Тест 1
Таблица 38 – Тест 1

|Тестовая ситуация:|Проверка корректности поведения программы при изменении глобальный настроек|
| :- | :- |
|Исходный набор данных:|Производится изменение глобальных настроек, включающих изменение условий правды и лжи для условного блока и изменение текста для блока по умолчанию на однострочный текст|
|Ожидаемый результат:|Изменение глобальный настроек|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.034.png)|

1. ### <a name="_toc135980294"></a>Тест 2
Таблица 39 – Тест 2

|Тестовая ситуация:|Проверка корректности поведения программы при изменении глобальный настроек|
| :- | :- |
|Исходный набор данных:|Производится изменение глобальных настроек, включающих изменение условий правды и лжи для условного блока и изменение текста для блока по умолчанию на многострочный текст|
|Ожидаемый результат:|Изменение глобальный настроек|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.035.png)|

1. ## <a name="_toc135980295"></a>**Тестирование формы frmPenSettings**
   1. ### <a name="_toc135980296"></a>Тест 1
Таблица 40 – Тест 1

|Тестовая ситуация:|Проверка корректности поведения программы при изменении кисти|
| :- | :- |
|Исходный набор данных:|Выполняется настройка кисти: толщина линии 10, цвет синий|
|Ожидаемый результат:|Изменение визуального отображения схемы|







Продолжение таблицы 40

|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.036.png)|
| :- | :-: |

1. ### <a name="_toc135980297"></a>Тест 2
Таблица 41 – Тест 2

|Тестовая ситуация:|Проверка корректности поведения программы при изменении кисти|
| :- | :- |
|Исходный набор данных:|Выполняется настройка кисти: толщина линии 4, цвет красный|
|Ожидаемый результат:|Изменение визуального отображения схемы|
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.037.png)|







1. ## <a name="_toc135980298"></a>**Тестирование формы frmHelp**
   1. ### <a name="_toc135980299"></a>Тест 1
Таблица 42 – Тест 1

|Тестовая ситуация:|Проверка корректности поведения программы при открытии формы Help с параметром «UserGuide»|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbUserGuide|
|Ожидаемый результат:|Отображение справочного материала и руководства |
|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.038.png)|
1. ### <a name="_toc135980300"></a>Тест 2
Таблица 43 – Тест 2

|Тестовая ситуация:|Проверка корректности поведения программы при открытии формы Help с параметром «About»|
| :- | :- |
|Исходный набор данных:|Нажатие на кнопку tbAbout|
|Ожидаемый результат:|Отображение информации об авторе |










Продолжение таблицы 43

|Полученный результат:|![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.039.png)|
| :- | :-: |
1. # <a name="_toc135506627"></a><a name="_toc135980301"></a>**РУКОВОДСТВО ПО УСТАНОВКЕ**
   1. ## <a name="_toc135567372"></a><a name="_toc135980302"></a>**Минимальные системные требования**
Для успешного запуска данного программного средства и комфортной работы с ним необходимо соответствие минимальным системным требованиям:

- процессор 1000 МГц или выше;
- объем оперативной памяти не менее 32 МБ;
- свободное место на диске не менее 21.5 МБ; 
- операционная система Windows XP и выше.

1. ## <a name="_toc135567373"></a><a name="_toc135980303"></a>**Установка**
На установочном диске содержится установочный файл программного средства. После открытия этого пакета, на экране появляется окно, изображенное на рисунке 4.1. В этом окне предоставляется возможность выбрать язык установки. Установщик предлагает выбор между русским и английским языками.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.040.png)

Рисунок 4.1 – Выбор языка


После выбора языка установки, появляется приветственное окно, изображенное на рисунке 4.2. В этом окне рекомендуется закрыть все активные приложения перед продолжением установки. Затем, предлагается нажать на кнопку «Далее», чтобы перейти к следующему шагу установки.






![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.041.png)

Рисунок 4.2 – Установка

После приветствия и рекомендации закрыть приложения, пользователь переходит к следующему этапу - просмотру и принятию лицензионного соглашения. Окно, изображенное на рисунке 4.3, содержит текст лицензионного соглашения, который может быть прочитан пользователем. После ознакомления с условиями лицензии, пользователь может принять их, нажав на соответствующую кнопку для продолжения установки.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.042.png)

Рисунок 4.3 – Лицензионное Соглашение

На следующем этапе предлагается выбрать место для установки программного средства. На рисунке 4.4 иллюстрируется этот этап, где можно обратить внимание на информацию о минимальном требуемом объеме свободного дискового пространства, необходимого для загрузки приложения на диск (21.5 МБ).

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.043.png)

Рисунок 4.4 – Выбор папки установки

Далее предоставляется возможность выбрать дополнительные параметры загрузки. Один из параметров - создание ярлыка в меню «Пуск». Окно с настройкой этой функции представлено на рисунке 4.5. Это позволяет установить ярлык приложения в меню «Пуск» для более удобного доступа из главного меню операционной системы.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.044.png)

Рисунок 4.5 – Выбор папки в меню «Пуск»

На следующем этапе установки данного программного средства, предлагается создать ярлык на Рабочем столе. Окно, показанное на рисунке 4.6, отображает эту опцию. Здесь можно выбрать создание значка на Рабочем столе, что обеспечит удобный доступ к программе прямо с Рабочего стола операционной системы.


![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.045.png)

Рисунок 4.6 – Дополнительные задачи

По завершении этапа подготовки к установке, предлагается установить программное средство на компьютер. Окно, показанное на рисунке 4.7, отображает данное предложение. В этом окне можно подтвердить намерение установить программу и начать процесс установки на компьютере.


![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.046.png)

Рисунок 4.7 – Установка

По завершении установки программного средства, пользователю предоставляется информация об успешном завершении процесса. Эта информация отображается в окне, представленном на рисунке 4.8. Здесь пользователь получает подтверждение того, что установка прошла успешно и программное средство готово к использованию.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.047.png)

Рисунок 4.8 – Завершение


1. ## <a name="_toc135980304"></a>**Работа с приложением**
После установки и запуска графического редактора для создания схем по методу Насси-Шнейдермана, пользователь попадает в рабочее окно, которое специально разработано для этой цели. Это окно, изображенное на рисунке 4.9, предоставляет пользователю все необходимые инструменты и функции для создания и редактирования схем, основанных на графическом подходе Насси-Шнейдермана. Здесь пользователь может легко проектировать и визуализировать структуру программы, используя блоки, связи и другие элементы, чтобы отобразить логику управления и последовательность действий в понятной и наглядной форме.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.048.png)

Рисунок 4.9 – Окно программы

Для добавления блоков в программу доступны следующие кнопки, которые можно увидеть на рисунке 4.10. 

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.049.png)

Рисунок 4.10 – Список доступных блоков

В наборе блоков имеются блок процесса, условный блок, блок множественного выбора, цикл с предусловием и цикл с постусловием. Блок процесса используется для представления последовательности действий или операций. Условный блок позволяет определить ветвление в программе в зависимости от выполнения определенного условия. Блок множественного выбора предоставляет возможность выбора из нескольких вариантов в зависимости от значения переменной или условия. Цикл с предусловием позволяет многократно выполнять блок кода, пока определенное условие остается истинным. Цикл с постусловием позволяет многократно выполнять блок кода, и затем проверять условие для продолжения или прерывания цикла. Эти блоки предоставляют программисту гибкость и функциональность для построения структуры программы в соответствии с требуемой логикой и потоком выполнения.

Для создания блока необходимо сначало указать соответствующее действие, как показано на рисунке 4.11.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.050.png)

Рисунок 4.11 – Ввод действия

При создании блока множественного выбора также требуется задать условия для каждого варианта. Этот процесс наглядно демонстрируется на рисунке 4.12.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.051.png)

Рисунок 4.12 – Ввод условий

В программе предусмотрены различные настройки, которые позволяют настраивать отображение схемы в соответствии с предпочтениями пользователя. Настройки включают в себя возможность изменения шрифта, выбор определенной кисти, а также настройку различных цветов для разных сценариев. Эти настройки позволяют пользователю настроить внешний вид схемы в соответствии с их предпочтениями и создать уникальный стиль для своих сценариев. Благодаря этим настройкам, пользователи получают больше гибкости и контроля над визуальным представлением своих схем.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.052.png)

Рисунок 4.13 – Настройки

В заключение, для более подробной информации о функциях и настройках программного средства, рекомендуется обратиться к «User Guide» (Руководство пользователя). В нем вы найдете всю необходимую информацию о работе с программой, включая подробные инструкции, советы и рекомендации. Данное руководство является ценным ресурсом, который поможет вам максимально эффективно использовать программное средство и достичь желаемых результатов.

![](Img/Aspose.Words.ba042c61-e582-442c-a78c-6b3d348777ba.053.png)

Рисунок 4.14 – Руководство пользователя




<a name="_toc135567375"></a><a name="_toc135980305"></a>**ЗАКЛЮЧЕНИЕ**

В результате выполнения данного курсового проекта был разработан графический редактор для создания схем Насси-Шнейдермана. Разработка такого программного средства является важным шагом в области программирования и проектирования алгоритмов. Графический подход, предоставляемый этим редактором, позволяет программистам визуализировать и структурировать свои алгоритмы, что упрощает процесс разработки и повышает эффективность программ.

Редактор предоставляет несколько типов блоков, таких как блок процесса, условный блок, блок множественного выбора, цикл с предусловием и цикл с постусловием. Каждый блок может быть создан с помощью соответствующей кнопки на графическом интерфейсе программы.

Для удобства пользователей редактор предлагает настройки, которые позволяют настроить шрифт, кисть, а также выбрать различные цвета для различных сценариев. Настройки доступны через соответствующие кнопки в программе.

В ходе разработки данного программного средства были применены знания и навыки работы с векторной графикой, динамическими структурами данных, а также взаимодействием с файлами. Был учтен графический интерфейс пользователя, чтобы обеспечить удобство использования программы.

Данная работа не исчерпывает все возможности и потенциал разработки графического редактора для схем Насси-Шнейдермана. В будущем можно рассмотреть возможности оптимизации алгоритмов, добавления новых функций и улучшения интерфейса, чтобы обеспечить еще более удобное и эффективное использование программы.

В целом, разработка данного программного средства для создания схем Насси-Шнейдермана является актуальной и востребованной задачей, помогающей программистам в их повседневной работе и упрощающей процесс разработки программного обеспечения.