unit uLocalSave;

interface
uses
  UBlockManager, uBase, System.JSON, System.Classes, uIfBranching, Vcl.Graphics,
  System.SysUtils, System.IOUtils, System.UITypes, uCaseBranching, uAdditionalTypes,
  uStatementConverter;

  procedure SaveSchema(const ABlockManager: TBlockManager);
  procedure LoadSchema(const ABlockManager: TBlockManager);
implementation

  { Pen }

  // Load
  procedure JSONToPen(const AJSON: TJSONObject; const APen: TPen);
  begin
    APen.Color := StringToColor(AJSON.GetValue('Color').Value);
    APen.Width := AJSON.GetValue('Width').Value.ToInteger;
    APen.Style := TPenStyle(AJSON.GetValue('Style').Value.ToInteger);
    APen.Mode := TPenMode(AJSON.GetValue('Mode').Value.ToInteger);
  end;

  // Save
  function PenToJSON(const APen: TPen): TJSONObject;
  begin
    Result := TJSONObject.Create;
    Result.AddPair('Color', ColorToString(APen.Color));
    Result.AddPair('Width', TJSONNumber.Create(APen.Width));
    Result.AddPair('Style', TJSONNumber.Create(Ord(APen.Style)));
    Result.AddPair('Mode', TJSONNumber.Create(Ord(APen.Mode)));
  end;

  { Font }
  function GetOrdFontStyle(AFontStyles: TFontStyles): Integer;
  begin
    Result := Ord(fsBold in AFontStyles) shl 3 or
              Ord(fsItalic in AFontStyles) shl 2 or
              Ord(fsUnderline in AFontStyles) shl 1 or
              Ord(fsStrikeOut in AFontStyles);
  end;

  function GetFontStyleFromOrd(AOrd: Integer): TFontStyles;
  begin
    Result := [];
    if AOrd and $01 = $01 then
      Include(Result, fsStrikeOut);
    if AOrd and $02 = $02 then
      Include(Result, fsUnderline);
    if AOrd and $04 = $04 then
      Include(Result, fsItalic);
    if AOrd and $08 = $08 then
      Include(Result, fsBold);
  end;

  // Load
  procedure JSONToFont(const AJSON: TJSONObject; const AFont: TFont);
  begin
    AFont.Size := AJSON.GetValue('Size').Value.ToInteger;
    AFont.Name := AJSON.GetValue('Name').Value;
    AFont.Color := StringToColor(AJSON.GetValue('Color').Value);
    AFont.Style := GetFontStyleFromOrd(AJSON.GetValue('Style').Value.ToInteger);
    AFont.Charset := AJSON.GetValue('Charset').Value.ToInteger;
  end;

  // Save
  function FontToJSON(const AFont: TFont): TJSONObject;
  begin
    Result := TJSONObject.Create;
    Result.AddPair('Size', TJSONNumber.Create(AFont.Size));
    Result.AddPair('Name', AFont.Name);
    Result.AddPair('Color', ColorToString(AFont.Color));
    Result.AddPair('Style', TJSONNumber.Create(GetOrdFontStyle(AFont.Style)));
    Result.AddPair('Charset', TJSONNumber.Create(Ord(AFont.Charset)));
  end;

  { Statement }

  // Load
  function JSONToBlock(const JsonObject: TJSONObject; const ABaseOperator: TOperator;
                       const ACanvas: TCanvas): TBlock; forward;

  function JSONToStatement(const JsonObject: TJSONObject; const ACanvas: TCanvas): TStatement;
  var
    CurrOperator: TOperator;
    MyJSONArray: TJSONArray;
    I: Integer;
    StatementClass: TStatementClass;
  begin
    StatementClass := ConvertToStatementType(JsonObject.GetValue('StatementIndex').Value.ToInteger);

    if StatementClass = TCaseBranching then
    begin
      MyJSONArray := TJSONArray(JsonObject.GetValue('Conds'));
      var StringArr : TStringArr;
      SetLength(StringArr, MyJSONArray.Count);
      for I := 0 to MyJSONArray.Count - 1 do
        StringArr[I] := MyJSONArray.Items[I].Value;
      Result:= TCaseBranching.Create(JsonObject.GetValue('Action').Value, StringArr);
    end
    else
      Result:= StatementClass.Create(JsonObject.GetValue('Action').Value);

    Result.SetCoords(JsonObject.GetValue('YStart').Value.ToInteger,
                     JsonObject.GetValue('YLast').Value.ToInteger);

    if Result is TOperator then
    begin
      CurrOperator:= TOperator(Result);

      MyJSONArray := TJSONArray(JsonObject.GetValue('Blocks'));
      for I := 0 to MyJSONArray.Count - 1 do
        CurrOperator.Blocks[I] := JSONToBlock(TJSONObject(MyJSONArray.Items[I]), CurrOperator, ACanvas);
    end;
  end;

  // Save
  function BlockToJSON(const ABlock: TBlock): TJSONObject; forward;

  function StatementToJSON(const AStatement: TStatement): TJSONObject;
  var
    CurrOperator: TOperator;
    MyJSONArray: TJSONArray;
    I: Integer;
  begin
    Result := TJSONObject.Create;
    Result.AddPair('StatementIndex', TJSONNumber.Create(
           ConvertToStatementIndex(TStatementClass(AStatement.ClassType))));
    Result.AddPair('Action', AStatement.Action);
    Result.AddPair('YStart', TJSONNumber.Create(AStatement.YStart));
    Result.AddPair('YLast', TJSONNumber.Create(AStatement.YLast));

    if AStatement is TOperator then
    begin
      CurrOperator:= TOperator(AStatement);

      if CurrOperator is TCaseBranching then
      begin
        MyJSONArray := TJSONArray.Create;
        var StringArr : TStringArr := TCaseBranching(CurrOperator).Conds;
        for I := 0 to High(StringArr) do
          MyJSONArray.Add(StringArr[I]);
        Result.AddPair('Conds', MyJSONArray);
      end;

      MyJSONArray := TJSONArray.Create;
      for I := 0 to High(CurrOperator.Blocks) do
        MyJSONArray.AddElement(BlockToJSON(CurrOperator.Blocks[I]));
      Result.AddPair('Blocks', MyJSONArray);
    end;
  end;

  { Block }

  // Load
  function JSONToBlock(const JsonObject: TJSONObject; const ABaseOperator: TOperator;
                       const ACanvas: TCanvas): TBlock;
  var
    JsonArray: TJSONArray;
    I: Integer;
  begin
    Result := TBlock.Create(
              JsonObject.GetValue('XStart').Value.ToInteger,
              JsonObject.GetValue('XLast').Value.ToInteger,
              ABaseOperator,
              ACanvas);

    JsonArray := TJSONArray(JsonObject.GetValue('Statements'));
    for I := 0 to JsonArray.Count - 1 do
      Result.AddStatement(JSONToStatement(TJSONObject(JsonArray.Items[I]), ACanvas));
  end;

  // Save
  function BlockToJSON(const ABlock: TBlock): TJSONObject;
  var
    I: Integer;
    JsonArray: TJsonArray;
  begin
    Result := TJSONObject.Create;

    Result.AddPair('XStart', TJSONNumber.Create(ABlock.XStart));
    Result.AddPair('XLast', TJSONNumber.Create(ABlock.XLast));

    JsonArray := TJsonArray.Create;

    for I := 0 to ABlock.Statements.Count - 1 do
      JsonArray.AddElement(StatementToJSON(ABlock.Statements[I]));

   Result.AddPair('Statements', JsonArray);
  end;

  { Schema }

  // Save
  procedure SaveSchema(const ABlockManager: TBlockManager);
  var
    Json: TJSONObject;
  begin
    Json := TJSONObject.Create;
    try
      with Json do
      begin
        with ABlockManager do
        begin
          AddPair('Pen', PenToJSON(Pen));
          AddPair('Font', FontToJSON(Font));
          AddPair('MainBlock', BlockToJSON(MainBlock));
        end;
      end;
      TFile.WriteAllText('Temp.json', Json.ToJSON, TEncoding.UTF8);
    finally
      Json.Destroy;
    end;
  end;

  // Load
  procedure LoadSchema(const ABlockManager: TBlockManager);
  var
    Json: TJSONObject;
  begin
    if TFile.Exists('Temp.json') then
    begin
      Json := TJSONObject.ParseJSONValue(TFile.ReadAllText('Temp.json', TEncoding.UTF8)) as TJSONObject;
      try
        with Json do
        begin
          with ABlockManager do
          begin
            JSONToPen(TJSONObject(GetValue('Pen')), Pen);
            JSONToFont(TJSONObject(GetValue('Font')), Font);
            MainBlock := JSONToBlock(TJSONObject(GetValue('MainBlock')), nil, PaintBox.Canvas);
          end;
        end;
      finally
        Json.Destroy;
      end;
    end;
  end;
end.
