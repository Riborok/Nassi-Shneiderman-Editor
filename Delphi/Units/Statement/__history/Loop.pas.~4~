unit Loop;

interface
uses Base, Vcl.ExtCtrls;

type
  TLoop = class abstract(TOperator)
  protected const
    FBlockCount = 1;
  protected
    FBlock: TBlockArr;
    procedure CreateBlock(const ABaseBlock: TBlock); override;
    function GetAmountOfPixelCorrection: Integer;
    function GetOptimalWidthForBlock(const ABlock: TBlock): Integer; override;
    procedure SetInitiaXLast; override;
  public
    constructor Create(AYStart: Integer; const AAction: string;
                const ABaseBlock: TBlock; const AImage: TImage); virtual;
    destructor Destroy; override;
    function GetXLastStrip: Integer;
    function GetBlocks: TBlockArr; override;
    function GetBlockCount: Integer; override;
  end;


implementation

  constructor TLoop.Create(AYStart: Integer; const AAction:
                         string; const ABaseBlock: TBlock; const AImage: TImage);
  begin
    inherited Create(AYStart, AAction, ABaseBlock, AImage);
  end;

  destructor TLoop.Destroy;
  begin

    FBlock[0].Destroy;

    inherited;
  end;

  procedure TLoop.CreateBlock(const ABaseBlock: TBlock);
  begin
    SetLength(FBlock, FBlockCount);
    FBlock[0] := TBlock.Create(GetXLastStrip, ABaseBlock.XLast, Self);
  end;

  procedure TLoop.SetInitiaXLast;
  begin
    FBlock[0].SetOptimalXLastBlock;
  end;

  function TLoop.GetXLastStrip: Integer;
  begin
    Result:= FBaseBlock.XStart + GetAmountOfPixelCorrection;
  end;

  function TLoop.GetAmountOfPixelCorrection: Integer;
  begin
    Result:= 2 * FImage.Canvas.Font.Size + 5;
  end;

  function TLoop.GetBlocks: TBlockArr;
  begin
    Result:= FBlock;
  end;

  function TLoop.GetBlockCount: Integer;
  begin
    Result:= FBlockCount;
  end;

  function TLoop.GetOptimalWidthForBlock(const ABlock: TBlock): Integer;
  begin
    Result:= -1;

    if ABlock = FBlock[0] then
      Result:= BaseBlock.XLast - GetXLastStrip;
  end;

end.
