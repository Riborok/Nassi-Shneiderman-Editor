unit IfBranching;

interface
uses Base, vcl.graphics, ProcessStatement, DrawShapes, MinMaxInt;
type

  TIfBranching = class(TOperator)
  private
    Blocks: TBlockArr;
    function GetAvailablePartWidth(const PartWidth, ATextHeight: Integer): Integer;
    function GetMinValidPartWidth(const ATextHeight, ATextWigth: Integer): Integer;
  protected
    procedure CreateBlock(const ABaseBlock: TBlock); override;
    procedure InitializeBlock; override;
    function GetOptimalWidth: Integer; override;
    function GetOptimalWidthForBlock(const ABlock: TBlock): Integer; override;
    procedure SetInitiaWidth; override;
    function GetOptimalHeight: Integer; override;
  private class var
    TrueText, FalseText: string;
  private const
    BlockCount = 2;
  public
    destructor Destroy; override;
    constructor Create(AYStart: Integer; const AAction: string;
                       const ABaseBlock: TBlock; const ACanvas: TCanvas);
    procedure Draw; override;
    function GetBlocks: TBlockArr; override;
    function GetBlockCount: Integer; override;
  end;

implementation

  function TIfBranching.GetBlocks: TBlockArr;
  begin
    result:= Blocks;
  end;

  function TIfBranching.GetBlockCount: Integer;
  begin
    result:= BlockCount;
  end;

  destructor TIfBranching.Destroy;
  begin

    Blocks[0].Destroy;
    Blocks[1].Destroy;

    inherited;
  end;

  procedure TIfBranching.CreateBlock (const ABaseBlock: TBlock);
  begin
    SetLength(Blocks, BlockCount);

    Blocks[0]:= TBlock.Create(
                       ABaseBlock.XStart,
                       (ABaseBlock.XStart + ABaseBlock.XLast) div 2, Self);

    Blocks[1]:= TBlock.Create(Blocks[0].XLast, ABaseBlock.XLast, Self);
  end;

  constructor TIfBranching.Create(AYStart: Integer; const AAction:
                           string; const ABaseBlock: TBlock; const ACanvas: TCanvas);
  begin
    inherited Create(AYStart, AAction, ABaseBlock, ACanvas);
  end;

  procedure TIfBranching.InitializeBlock;
  var
    NewStatement: TStatement;
  begin
    NewStatement:= TProcessStatement.CreateUncertainty(FYLast, Blocks[0], FCanvas);
    Blocks[0].Statements.Add(NewStatement);
    NewStatement.SetOptimalHeight;

    NewStatement:= TProcessStatement.CreateUncertainty(FYLast, Blocks[1], FCanvas);
    Blocks[1].Statements.Add(NewStatement);
    NewStatement.SetOptimalHeight;
  end;

  function TIfBranching.GetOptimalWidthForBlock(const ABlock: TBlock): Integer;
  begin
    Result:= -1;
    if ABlock = Blocks[0] then
      result:= GetMinValidPartWidth(GetTextHeight(FCanvas, TrueText),
                                              GetTextWidth(FCanvas, TrueText))
    else if ABlock = Blocks[1] then
      result:= GetMinValidPartWidth(GetTextHeight(FCanvas, FalseText),
                                              GetTextWidth(FCanvas, FalseText));
  end;

  function TIfBranching.GetOptimalWidth: Integer;
  begin
    Result:= Max(
          GetMinValidPartWidth(
              GetTextHeight(FCanvas, FAction), GetTextWidth(FCanvas, FAction)),
          GetMinValidPartWidth(
             GetTextHeight(FCanvas, TrueText), GetTextWidth(FCanvas, TrueText))
             +
          GetMinValidPartWidth(
             GetTextHeight(FCanvas, FalseText), GetTextWidth(FCanvas, FalseText))
          );
  end;

  function TIfBranching.GetOptimalHeight: Integer;
  begin
    Result := FYStart + GetTextHeight(FCanvas, TrueText) +
              GetTextHeight(FCanvas, FAction) + 3 * YIndentText;
  end;

  function TIfBranching.GetAvailablePartWidth(const PartWidth, ATextHeight: Integer): Integer;
  begin
    Result:= PartWidth *
             (FYLast - FYStart - ATextHeight - YIndentText) div (FYLast - FYStart);
  end;

  function TIfBranching.GetMinValidPartWidth(const ATextHeight,
                                             ATextWigth: Integer): Integer;
  begin
    Result:= (ATextWigth + 2 * XMinIndentText) *
             (FYLast - FYStart) div (FYLast - FYStart - ATextHeight - YIndentText);
  end;

  procedure TIfBranching.SetInitiaWidth;
  begin
    Blocks[0].SetOptimalXLastBlock;
  end;

  procedure TIfBranching.Draw;
  var
    TrueWidth, TrueHeight: Integer;
    FalseWidth, FalseHeight: Integer;
    TextWidth, TextHeight: Integer;
    Right: Integer;
  begin

    // Calculate the dimensions of the text
    TextWidth := GetTextWidth(FCanvas, FAction);
    TextHeight := GetTextHeight(FCanvas, FAction);

    TrueWidth := GetTextWidth(FCanvas, TrueText);
    TrueHeight := GetTextHeight(FCanvas, TrueText);

    FalseWidth := GetTextWidth(FCanvas, FalseText);
    FalseHeight := GetTextHeight(FCanvas, FalseText);

    // Drawing the main block
    DrawRectangle(BaseBlock.XStart, BaseBlock.XLast, FYStart, FYLast, FCanvas);

    // Drawing the text
    DrawText(FCanvas,
      Blocks[0].XStart +
      GetAvailablePartWidth(Blocks[0].XLast - Blocks[0].XStart, TextHeight) +
      GetAvailablePartWidth(BaseBlock.XLast - BaseBlock.XStart, TextHeight) div 2 -
      TextWidth div 2,
      FYStart + YIndentText, Action);

    // Drawing the True and False text
    DrawText(FCanvas,
                    Blocks[0].XStart + GetAvailablePartWidth(
                    Blocks[0].XLast - Blocks[0].XStart, TrueHeight) div 2 -
                    TrueWidth div 2,
                    FYStart + 2*YIndentText + TextHeight, TrueText);

    DrawText(FCanvas,
                    Blocks[1].XLast - GetAvailablePartWidth(
                    Blocks[1].XLast - Blocks[1].XStart, FalseHeight) div 2 -
                    FalseWidth div 2,
                    FYStart + 2*YIndentText + TextHeight, FalseText);

    DrawInvertedTriangle(BaseBlock.XStart, Blocks[0].XLast, BaseBlock.XLast,
                                                      FYStart, FYLast, FCanvas);

    Blocks[0].DrawBlock;
    Blocks[1].DrawBlock;
  end;


  initialization
  TIfBranching.TrueText := 'False';
  TIfBranching.FalseText := 'True';

end.
