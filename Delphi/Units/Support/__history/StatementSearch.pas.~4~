unit StatementSearch;

interface
uses Base;

  function BinarySearchStatement(const AX, AY: Integer; const ABlock: TBlock): TStatement;
implementation

  function BinarySearchStatement(const AX, AY: Integer; const ABlock: TBlock): TStatement;
  var
    L, R, M: Integer;
    CurrOperator: TOperator;
    Blocks: TBlockArr;
    Statement: TStatement;

    function BinarySearchBlockArray(const Blocks: TBlockArr; const AX: Integer): TBlock;
    var
      L, R, Mid: Integer;
    begin

      Result := nil;
      L := 0;
      R := High(Blocks);
      while L <= R do

      begin
        Mid := (L + R) div 2;

        if (AX >= Blocks[Mid].XStart) and (AX <= Blocks[Mid].XLast) then
          Exit(Blocks[Mid])

        else if AX < Blocks[Mid].XStart then
          R := Mid - 1
        else
          L := Mid + 1;
      end;
    end;
  begin
    Result := nil;

    if (AX >= ABlock.XStart) and (AX <= ABlock.XLast) then
    begin

      // Perform binary search to find the statement
      L := 0;
      R := ABlock.Statements.Count - 1;

      while L <= R do
      begin

        M := (L + R) div 2;
        Statement := ABlock.Statements[M];

        if (AY >= Statement.YStart) and (AY <= Statement.GetYBottom) then
        begin

          if (Statement is TOperator) then
          begin

            CurrOperator:= TOperator(Statement);

            Blocks:= CurrOperator.GetBlocks;

            // ПОТОМ ДОПИСАТЬ ЛОГИКУ ДЛЯ ЦИКЛОВ (ЧТО У НИХ ЕСТЬ ЛЕВАЯ ПОЛОСА
            // И ПРИ ТЫКИ НА НЕЕ ТОЖЕ ВЫДЕЛЯЕТСЯ ЭТОТ ЦИКЛ
            if AY <= CurrOperator.YLast then
              Exit(Statement);

            Exit(BinarySearchStatement(AX, AY, BinarySearchBlockArray(Blocks, AX)));

          end
          else
            Exit(Statement);


        end
        else if AY < Statement.YStart then
          R := M - 1
        else
          L := M + 1;
      end;
    end

  end;

  function Max(const AFirstNum, B: Integer): Integer;
  begin
    if AFirstNum > B then
      Result := AFirstNum
    else
      Result := B;
  end;

end.
