unit DrawShapes;

interface
uses Vcl.graphics, System.StrUtils, System.Types, System.SysUtils, MinMaxInt;

procedure DrawRectangle(const AXStart, AXLast, AYStart, AYLast : Integer; const ACanvas: TCanvas);
procedure DrawInvertedTriangle(const AXStart, AXMiddle, AXLast, AYStart, AYLast : Integer; const ACanvas: TCanvas);
procedure DrawYellowRect(const ACanvas: TCanvas; const AXStart, AXLast, AYStart, AYLast: Integer);

function GetTextHeight(const ACanvas: TCanvas; const AText: string): Integer;
procedure DrawText(const ACanvas: TCanvas; const AX, AY: Integer; const AText: string);
function GetTextWidth(const FCanvas: TCanvas; const Text: string): Integer;

procedure DrawAxesWithLabels(Canvas: TCanvas);
implementation


  procedure DrawRectangle(const AXStart, AXLast, AYStart, AYLast : Integer; const ACanvas: TCanvas);
  begin
    ACanvas.MoveTo(AXStart, AYStart);
    ACanvas.LineTo(AXLast, AYStart);
    ACanvas.LineTo(AXLast, AYLast);
    ACanvas.LineTo(AXStart, AYLast);
    ACanvas.LineTo(AXStart, AYStart);
  end;

  procedure DrawInvertedTriangle(const AXStart, AXMiddle, AXLast, AYStart, AYLast : Integer; const ACanvas: TCanvas);
  begin
    ACanvas.MoveTo(AXStart, AYStart);
    ACanvas.LineTo(AXMiddle, AYLast);
    ACanvas.LineTo(AXLast, AYStart);
  end;

  procedure DrawYellowRect(const ACanvas: TCanvas; const AXStart, AXLast, AYStart, AYLast: Integer);
  var
    SavedColor: TColor;
  begin
    SavedColor := ACanvas.Brush.Color;

    ACanvas.Brush.Color := clYellow;
    ACanvas.FillRect(Rect(AXStart, AYStart, AXLast, AYLast));

    ACanvas.Brush.Color := SavedColor;
  end;

  procedure DrawText(const ACanvas: TCanvas; const AX, AY: Integer; const AText: string);
  var
    Lines: TStringDynArray;
    LineHeight: Integer;
    I: Integer;
    SavedColor: TColor;
  begin
    SavedColor := ACanvas.Brush.Color;
    ACanvas.Brush.Style := bsClear;

    Lines := SplitString(AText, sLineBreak);

    LineHeight := ACanvas.TextHeight(' ') div 2;

    for I := 0 to High(Lines) do
      ACanvas.TextOut(AX, AY + I * LineHeight, Lines[i]);

    ACanvas.Brush.Color := SavedColor;
  end;

  function GetTextHeight(const ACanvas: TCanvas; const AText: string): Integer;
  var
    Lines: TStringDynArray;
    i: Integer;
  begin
    Result := 0;
    Lines := SplitString(AText, sLineBreak);

    Inc(Result, ACanvas.TextHeight(Lines[0]));
    for i := 1 to High(Lines) do
    begin
      if Length(Lines[i]) > 0 then
        Inc(Result, ACanvas.TextHeight(Lines[i]))
      else if Length(Lines[i - 1]) = 0 then
        Inc(Result, ACanvas.Font.Size);
    end;

  end;

  function GetTextWidth(const FCanvas: TCanvas; const Text: string): Integer;
  var
    Lines: TStringDynArray;
    i: Integer;
  begin
    Result := 0;
    Lines := SplitString(Text, sLineBreak);

    for i := 0 to High(Lines) do
      Result := Max(Result, FCanvas.TextWidth(Lines[i]));
  end;



procedure DrawAxesWithLabels(Canvas: TCanvas);
begin
  // Определяем границы Canvas
  Canvas.Pen.Color := clBlack;
  Canvas.Pen.Width := 1;
  Canvas.Brush.Style := bsClear;
  Canvas.Rectangle(Canvas.ClipRect);

  // Рисуем ось X
  Canvas.MoveTo(Canvas.ClipRect.Left, Canvas.ClipRect.Top);
  Canvas.LineTo(Canvas.ClipRect.Right, Canvas.ClipRect.Top);

  // Рисуем деления на оси X
  Canvas.Pen.Width := 0;
  Canvas.Font.Size := 8;

  for var i := 0 to Canvas.ClipRect.Right div 50 do
  begin
    var XPos := i * 50;
    Canvas.MoveTo(XPos, Canvas.ClipRect.Top);
    Canvas.LineTo(XPos, Canvas.ClipRect.Bottom);

    Canvas.TextOut(XPos - Canvas.TextWidth(IntToStr(i * 50)) div 2,
      Canvas.ClipRect.Top + 10, IntToStr(i * 50));
  end;

  // Рисуем ось Y
  Canvas.MoveTo(Canvas.ClipRect.Left, Canvas.ClipRect.Top);
  Canvas.LineTo(Canvas.ClipRect.Left, Canvas.ClipRect.Bottom);

  // Рисуем деления на оси Y
  for var i := 0 to Canvas.ClipRect.Bottom div 50 do
  begin
    var YPos := i * 50;
    Canvas.MoveTo(Canvas.ClipRect.Left, YPos);
    Canvas.LineTo(Canvas.ClipRect.Right, YPos);

    Canvas.TextOut(Canvas.ClipRect.Left + 10,
      YPos - Canvas.TextHeight(IntToStr(i * 50)) div 2, IntToStr(i * 50));
  end;
end;






end.
