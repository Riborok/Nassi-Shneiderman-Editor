unit frmGetСaseСonditions;
{
 Many conditions can be created, resulting in numerous components. It is a
 costly endeavor. A beautiful solution needs to be found, but currently,
 there is a lack of time to accomplish it :(
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, uAdditionalTypes, uStack, uConstants,
  Vcl.ExtCtrls, uMinMaxInt, Vcl.DBCtrls;

type
  TWriteCaseConditions = class(TForm)
    btnOK: TButton;
    lbAdd: TLabel;
    btnAdd: TButton;
    lbDel: TLabel;
    btnDelete: TButton;
    btnCancel: TButton;
    MainPanel: TPanel;
    ScrollBar: TScrollBar;
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormCreate(Sender: TObject);
    procedure btnAddClick(Sender: TObject);
    procedure btnDeleteClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private const
    constMinAmount = 2;
    constMaxAmount = 442;

    MemoAmount = 4;
    MemoHigh = MemoAmount - 1;

    LabelCaption = 'Condition ';
  private type

    TCondSet = record
      LabelCaption : TLabel;
      Memo : TMemo;
    end;
  private
    { Private declarations }
    FMemoHigh, FPointer: Integer;
    FConds : TStringArr;
    FCondsSet : array[0..MemoHigh] of TCondSet;

    procedure SetCondSetVisible(const ACondSetIndex: Integer; const AVisible: Boolean);
    procedure RefreshCondSet(const AIndex: Integer);
    procedure ScrollUp;
    procedure ScrollDown;
  public
    { Public declarations }
    function TryGetCond(var AConds: TStringArr): Boolean;
    destructor Destroy; override;
  end;

var
  WriteCaseConditions: TWriteCaseConditions;

implementation

{$R *.dfm}

  procedure TWriteCaseConditions.SetCondSetVisible(const ACondSetIndex: Integer; const AVisible: Boolean);
  begin
    FCondsSet[ACondSetIndex].LabelCaption.Visible := AVisible;
    FCondsSet[ACondSetIndex].Memo.Visible := AVisible;
  end;

  procedure TWriteCaseConditions.RefreshCondSet(const AIndex: Integer);
  begin
    FCondsSet[AIndex].Memo.Lines.Text := FConds[AIndex];
    FCondsSet[AIndex].LabelCaption.Caption := LabelCaption + IntToStr(AIndex);
  end;

  procedure TWriteCaseConditions.ScrollUp;
  var
    I: Integer;
  begin
    FConds[FPointer + MemoAmount - 1] := FCondsSet[MemoHigh].Memo.Lines.Text;

    Dec(FPointer);
    for I := MemoHigh downto Low(FCondsSet) + 1 do
    begin
      FCondsSet[I].Memo.Lines.Text := FCondsSet[I - 1].Memo.Lines.Text;
      FCondsSet[I].LabelCaption.Caption := LabelCaption + IntToStr(FPointer + I);
    end;

    FCondsSet[Low(FCondsSet)].Memo.Lines.Text := FConds[FPointer];
    FCondsSet[Low(FCondsSet)].LabelCaption.Caption := LabelCaption + IntToStr(FPointer);
  end;

  procedure TWriteCaseConditions.ScrollDown;
  var
    I: Integer;
  begin
    FConds[FPointer] := FCondsSet[Low(FCondsSet)].Memo.Lines.Text;

    Inc(FPointer);
    for I := Low(FCondsSet) to MemoHigh - 1 do
    begin
      FCondsSet[I].Memo.Lines.Text := FCondsSet[I + 1].Memo.Lines.Text;
      FCondsSet[I].LabelCaption.Caption := LabelCaption + IntToStr(FPointer + I);
    end;

    FCondsSet[MemoHigh].Memo.Lines.Text := FConds[FPointer + MemoHigh];
    FCondsSet[MemoHigh].LabelCaption.Caption := LabelCaption + IntToStr(FPointer + MemoHigh);
  end;

  function TWriteCaseConditions.TryGetCond(var AConds: TStringArr): Boolean;
  var
    I, MinCount: Integer;
  begin
    FPointer:= Low(FCondsSet);

    if AConds = nil then
    begin
      FMemoHigh := constMinAmount - 1;

      SetLength(FConds, FMemoHigh shl 1);

      for I := Low(FCondsSet) to FMemoHigh do
      begin
        SetCondSetVisible(I, True);

        FCondsSet[I].Memo.Lines.Text := '';
        FCondsSet[I].LabelCaption.Caption := LabelCaption + IntToStr(I);
      end;

      for I := FMemoHigh + 1 to MemoHigh do
        SetCondSetVisible(I, False);
    end
    else
    begin
      FMemoHigh := High(AConds);

      SetLength(FConds, Length(AConds) shl 1);
      Move(AConds[0], FConds[0], Length(AConds) * SizeOf(string));

      MinCount := Min(FMemoHigh, MemoHigh);
      for I := Low(FCondsSet) to MinCount do
      begin
        SetCondSetVisible(I, True);
        RefreshCondSet(I);
      end;

      for I := MinCount + 1 to MemoHigh do
        SetCondSetVisible(I, False);
    end;

    ShowModal;

    if Self.ModalResult = MrOk then
    begin
      Result:= True;
      SetLength(AConds, FMemoHigh + 1);

      for I := Low(FCondsSet) to FMemoHigh do
        FConds[FPointer + I] := FCondsSet[I].Memo.Lines.Text;

      Move(FConds[0], AConds[0], (MemoHigh + 1) * SizeOf(string));
    end
    else
      Result:= False;
  end;

  procedure TWriteCaseConditions.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
  begin
    if Key = VK_ESCAPE then
      ModalResult := mrCancel
    else if (Key = VK_RETURN) and not (ssShift in Shift) then
      ModalResult := mrOk;
  end;

  procedure TWriteCaseConditions.btnAddClick(Sender: TObject);
  begin
    if FMemoHigh < constMaxAmount then
    begin
      Inc(FMemoHigh);

      if FMemoHigh > High(FConds) then
        SetLength(FConds, (FMemoHigh + 1) shl 1);

      if FMemoHigh <= MemoHigh then
      begin
        SetCondSetVisible(FMemoHigh, True);

        RefreshCondSet(FMemoHigh);
      end
      else
        ScrollDown;
    end;
  end;

  procedure TWriteCaseConditions.btnDeleteClick(Sender: TObject);
  begin
    if FMemoHigh >= constMinAmount then
    begin
      if FMemoHigh <= MemoHigh then
        SetCondSetVisible(FMemoHigh, False)
      else
        ScrollUp;

      Dec(FMemoHigh);
    end;
  end;

  procedure TWriteCaseConditions.FormCreate(Sender: TObject);
  const
    Indent = 5;
  var
    MemoHeight, FCondsSetWidth: Integer;
    I, CurrPosY: Integer;
  begin
    MemoHeight := (MainPanel.Height - mmFontSize * MemoAmount -
              MemoAmount * Indent - Indent shl 1) div MemoAmount - Indent shl 1;
    FCondsSetWidth:= ScrollBar.Left - Indent shl 1;

    CurrPosY:= Indent;
    for I := Low(FCondsSet) to MemoHigh do
    begin
      FCondsSet[I].LabelCaption := TLabel.Create(Self);
      FCondsSet[I].Memo := TMemo.Create(Self);

      with FCondsSet[I].LabelCaption do
      begin
        Parent := MainPanel;
        Left := Indent;
        Width := FCondsSetWidth;
        Top := CurrPosY;
        Font.Size := mmFontSize;
        Font.Name := mmFontName;
      end;

      Inc(CurrPosY, FCondsSet[I].LabelCaption.Height + Indent);

      with FCondsSet[I].Memo do
      begin
        Parent := MainPanel;
        Left := Indent;
        Width := FCondsSetWidth;
        Top := CurrPosY;
        Height := MemoHeight;
        Font.Size := mmFontSize;
        Font.Name := mmFontName;
      end;

      Inc(CurrPosY, MemoHeight + Indent);
    end;
  end;

  destructor TWriteCaseConditions.Destroy;
  var
    I: Integer;
  begin
    for I := Low(FCondsSet) to MemoHigh do
    begin
      FCondsSet[I].LabelCaption.Destroy;
      FCondsSet[I].Memo.Destroy;
    end;
    inherited;
  end;

  procedure TWriteCaseConditions.FormShow(Sender: TObject);
  begin
    Left := (Screen.Width - Width) shr 1;
    Top := (Screen.Height - Height) shr 1;
  end;

end.
