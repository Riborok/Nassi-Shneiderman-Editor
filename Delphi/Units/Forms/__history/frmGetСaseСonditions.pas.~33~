unit frmGet—ase—onditions;
{
 Many conditions can be created, resulting in numerous components. It is a
 costly endeavor. A beautiful solution needs to be found, but currently,
 there is a lack of time to accomplish it :(
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, uAdditionalTypes, uStack, uConstants,
  Vcl.ExtCtrls, uMinMaxInt, Vcl.DBCtrls;

type
  TWriteCaseConditions = class(TForm)
    btnOK: TButton;
    lbAdd: TLabel;
    btnAdd: TButton;
    lbDel: TLabel;
    btnDelete: TButton;
    btnCancel: TButton;
    MainPanel: TPanel;
    ScrollBar: TScrollBar;
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormCreate(Sender: TObject);
    procedure btnAddClick(Sender: TObject);
    procedure btnDeleteClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private const
    MinAmount = 2;
    MaxAmount = 442;
    MemoAmount = 4;
    LabelCaption = 'Condition ';
  private type

    TCondSet = record
      LabelCaption : TLabel;
      Memo : TMemo;
    end;
  private
    { Private declarations }
    FMemoCount, FPointer: Integer;
    FConds : TStringArr;
    FCondsSet : array[1..MemoAmount] of TCondSet;

    procedure SetCondSetVisible(const ACondSetIndex: Integer; const AVisible: Boolean);
    procedure RefreshCondSet(const ACondSetIndex, AIndex: Integer);
    procedure ScrollUp;
    procedure ScrollDown;
  public
    { Public declarations }
    function TryGetCond(var AConds: TStringArr): Boolean;
    destructor Destroy; override;
  end;

var
  WriteCaseConditions: TWriteCaseConditions;

implementation

{$R *.dfm}

  procedure TWriteCaseConditions.SetCondSetVisible(const ACondSetIndex: Integer; const AVisible: Boolean);
  begin
    FCondsSet[ACondSetIndex].LabelCaption.Visible := AVisible;
    FCondsSet[ACondSetIndex].Memo.Visible := AVisible;
  end;

  procedure TWriteCaseConditions.RefreshCondSet(const ACondSetIndex, AIndex: Integer);
  begin
    FCondsSet[ACondSetIndex].Memo.Lines.Text := FConds[AIndex];
    FCondsSet[ACondSetIndex].LabelCaption.Caption := LabelCaption + IntToStr(AIndex);
  end;

  procedure TWriteCaseConditions.ScrollUp;
  var
    I, J: Integer;
  begin
    Dec(FPointer);
    J:= Low(FCondsSet);
    for I := FPointer to FPointer + MemoAmount - 1 do
    begin
      RefreshCondSet(J, I);

      Inc(J);
    end;
  end;

  procedure TWriteCaseConditions.ScrollDown;
  var
    I, J: Integer;
  begin
    Inc(FPointer);
    J:= Low(FCondsSet);
    for I := FPointer to FPointer + MemoAmount - 1 do
    begin
      RefreshCondSet(J, I);

      Inc(J);
    end;
  end;

  function TWriteCaseConditions.TryGetCond(var AConds: TStringArr): Boolean;
  var
    I, MinCount: Integer;
  begin
    FPointer:= Low(FCondsSet);

    if AConds = nil then
    begin
      FMemoCount := MinAmount;

      SetLength(FConds, FMemoCount shl 1);

      for I := Low(FCondsSet) to FMemoCount do
      begin
        SetCondSetVisible(I, True);

        FCondsSet[I].Memo.Lines.Text := '';
        FCondsSet[I].LabelCaption.Caption := LabelCaption + IntToStr(I);
      end;

      for I := FMemoCount + 1 to High(FCondsSet) do
        SetCondSetVisible(I, False);
    end
    else
    begin
      FMemoCount := Length(AConds);

      SetLength(FConds, FMemoCount shl 1);

      Move(AConds[0], FConds[0], FMemoCount * SizeOf(string));

      MinCount := Min(FMemoCount, MemoAmount);
      for I := Low(FCondsSet) to MinCount do
      begin
        SetCondSetVisible(I, True);
        RefreshCondSet(I, I);
      end;

      for I := MinCount + 1 to High(FCondsSet) do
        SetCondSetVisible(I, False);
    end;

    ShowModal;

    if Self.ModalResult = MrOk then
    begin
      Result:= True;
      SetLength(AConds, FMemoCount);
      Move(FConds[0], AConds[0], FMemoCount * SizeOf(string));
    end
    else
      Result:= False;
  end;

  procedure TWriteCaseConditions.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
  begin
    if Key = VK_ESCAPE then
      ModalResult := mrCancel
    else if (Key = VK_RETURN) and not (ssShift in Shift) then
      ModalResult := mrOk;
  end;

  procedure TWriteCaseConditions.btnAddClick(Sender: TObject);
  begin
    if FMemoCount <= MaxAmount then
    begin
      Inc(FMemoCount);

      if FMemoCount > Length(FConds) then
        SetLength(FConds, FMemoCount shl 1);

      if FMemoCount <= MemoAmount then
      begin
        SetCondSetVisible(FMemoCount, True);

        RefreshCondSet(FMemoCount, FMemoCount);
      end
      else
        ScrollDown;
    end;
  end;

  procedure TWriteCaseConditions.btnDeleteClick(Sender: TObject);
  begin
    if FMemoCount > MinAmount then
    begin
      if FMemoCount <= MemoAmount then
        SetCondSetVisible(FMemoCount, False)
      else
        ScrollUp;

      Dec(FMemoCount);
    end;
  end;

  procedure TWriteCaseConditions.FormCreate(Sender: TObject);
  const
    Indent = 5;
  var
    MemoHeight, FCondsSetWidth: Integer;
    I, CurrPosY: Integer;
  begin
    MemoHeight := (MainPanel.Height - mmFontSize * MemoAmount -
              MemoAmount * Indent - Indent shl 1) div MemoAmount - Indent shl 1;
    FCondsSetWidth:= ScrollBar.Left - Indent shl 1;

    CurrPosY:= Indent;
    for I := Low(FCondsSet) to High(FCondsSet) do
    begin
      FCondsSet[I].LabelCaption := TLabel.Create(Self);
      FCondsSet[I].Memo := TMemo.Create(Self);

      with FCondsSet[I].LabelCaption do
      begin
        Parent := MainPanel;
        Left := Indent;
        Width := FCondsSetWidth;
        Top := CurrPosY;
        Font.Size := mmFontSize;
        Font.Name := mmFontName;
      end;

      Inc(CurrPosY, FCondsSet[I].LabelCaption.Height + Indent);

      with FCondsSet[I].Memo do
      begin
        Parent := MainPanel;
        Left := Indent;
        Width := FCondsSetWidth;
        Top := CurrPosY;
        Height := MemoHeight;
        Font.Size := mmFontSize;
        Font.Name := mmFontName;
      end;

      Inc(CurrPosY, MemoHeight + Indent);
    end;
  end;

  destructor TWriteCaseConditions.Destroy;
  var
    I: Integer;
  begin
    for I := Low(FCondsSet) to High(FCondsSet) do
    begin
      FCondsSet[I].LabelCaption.Destroy;
      FCondsSet[I].Memo.Destroy;
    end;
    inherited;
  end;

  procedure TWriteCaseConditions.FormShow(Sender: TObject);
  begin
    Left := (Screen.Width - Width) shr 1;
    Top := (Screen.Height - Height) shr 1;
  end;

end.
